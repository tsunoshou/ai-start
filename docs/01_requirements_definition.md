# 技術要件・開発要件の定義

最終更新日: 2025-04-04

## 本ドキュメントの目的

このドキュメントは、AiStartプロジェクトのビジネス要件、機能要件、非機能要件を定義しています。関連ドキュメントとの役割の違いは以下のとおりです：

- **01_requirements_definition.md**：「何を」実現するのか（What）
  - ビジネス・機能要件の定義
  - 非機能要件の定義
  - 技術スタックの概要
  - プロジェクト管理方法の概要

- **02_architecture_design.md**：「どのように」実現するのか（How）
  - アーキテクチャスタイルの選定と理由
  - ディレクトリ構造と各レイヤーの責務
  - モジュール分割と依存関係の設計
  - 認証・認可の実装アーキテクチャ
  - エラー処理戦略の詳細

- **03_prototype_development.md**：プロトタイプでの検証事項（Verify）
  - プロトタイプの目的と検証内容
  - 検証する技術項目と評価方法
  - プロトタイプの実装範囲と制限

- **04_implementation_rules.md**：「どのように書くか」（Write）
  - 具体的なコーディング規約と命名規則
  - 実装パターン集と具体的なコード例
  - 型定義と安全な変換関数の実装詳細
  - リポジトリパターンとRLSの実装詳細

このドキュメントは、プロジェクト全体の方向性を示し、何を作るべきかを明確にします。ここで定義された要件は、02_architecture_design.mdでのアーキテクチャ設計と04_implementation_rules.mdでの実装ルールの基礎となります。

## ビジネス・機能要件

### 概要

AiStartは、AI支援によるビジネスプラン作成支援SaaSプラットフォームです。ユーザーはステップバイステップで進めながら、OpenAI APIを活用した対話形式でビジネスプランを作成できます。1からの実装により、保守性・拡張性に優れたシステムを構築します。

### 主要機能

1. **ユーザー認証・管理機能**
   - OAuth2+OIDCベースの認証システム
   - ロールベースのアクセス制御（管理者/一般ユーザー）
     - **管理者ロール**: システム全体の管理権限を持つ（例: SuperAdmin）。ユーザー管理、プログラム・コンテンツ管理、サブスクリプションプラン管理など全ての管理機能にアクセス可能。
     - **一般ユーザーロール**: 自身のプロジェクト作成・管理、プログラム利用、サブスクリプション管理のみ可能。
   - ユーザープロフィール管理とカスタマイズ（一般ユーザー向け）
   + **管理者向けユーザー管理機能 (`user-management.tsx` 関連)**
     + 登録ユーザーの一覧表示（検索、フィルタリング、ページネーション機能を含む）
     + ユーザー詳細情報の参照
     + ユーザーロール（管理者/一般ユーザー）の変更
     + ユーザーアカウントの有効化/無効化

2. **プログラム（コース）管理**
   - 複数のビジネスプラン作成プログラム提供
   - **管理者向け操作**:
     - プログラムの新規作成、編集、複製、削除
     - プログラムの公開/非公開設定
     - プログラム一覧の管理（検索、フィルタリング機能）
   - プログラムの検索・フィルタリング機能（一般ユーザー向け）
   - プログラムごとの評価・レビュー機能（一般ユーザー向け）

3. **ステップ管理**
   - プログラム内のステップ構成とフロー管理
   - **管理者向け操作**:
     - 特定プログラムへのステップ新規作成、編集、複製、削除
     - ステップの順序変更と依存関係の設定
     - ステップ完了条件の設定
     - ステップ一覧の管理（プログラム内）
   - ステップごとの完了条件と進捗トラッキング（一般ユーザー向け）
   - 条件分岐型のステップフロー設計
   + **ステップ進行要件**:
     + 順序付き学習パスの提供とナビゲーション
     + 前提条件に基づく条件付きステップアクセス制御
     + ステップ間の依存関係の視覚化と管理
     + 進捗状況の保存と再開機能
   + **ステップ完了条件評価**:
     + 複合条件に基づくステップ完了判定（成果物作成、チェック完了、必須視聴など）
     + AIによるステップ成果物の品質評価
     + 条件未達成時のガイダンス提供
     + 管理者による手動完了承認オプション
   + **進捗の視覚化**:
     + 完了ステップ/現在のステップ/未着手ステップの視覚的区別
     + 全体進捗のダッシュボード表示
     + プロジェクト間での進捗比較
     + 想定所要時間と実績時間の表示

4. **コンテンツ管理**
   - ステップに紐づくプロンプトテンプレート管理
     - **管理者向け操作**:
       - プロンプトテンプレートの新規作成、編集、削除
       - プロンプトのバージョン管理（差分表示、ロールバック検討）
       - プロンプト一覧の管理 (A/Bテスト機能連携含む)
   - ステップに紐づく補助ビデオコンテンツ管理
     - **管理者向け操作**:
       - ビデオコンテンツのアップロード、編集、削除
       - ビデオメタデータ（タイトル、説明など）の管理
       - ビデオ一覧の管理
   - プロンプトのバージョン管理とA/Bテスト機能
   - マルチメディアコンテンツのアップロード・管理
   + **プロンプト管理要件**:
     + プロンプトテンプレートのバージョン管理システム
     + プロンプトタイプ別の最適化（開始時/継続時/チェック時/成果物作成時）
     + 動的変数置換によるコンテキスト適応
     + A/Bテストによるプロンプト効果測定
     + プロンプト改善のためのフィードバックループ
     + 管理者向けプロンプトエディターと効果プレビュー
     + プロンプト間の差分比較ツール
   + **ビデオコンテンツ管理要件**:
     + ステップに紐づく補完的学習ビデオリソース
     + マルチプロバイダー対応（YouTube, Vimeo, 内部ホスティング）
     + ビデオメタデータ管理（タイトル、説明、タグ、サムネイル）
     + 視聴進捗追跡と学習状況への統合
     + 条件付きステップ進行のための必須視聴確認
     + 統一されたプレーヤーインターフェース
     + 再生位置の記録と復元機能
     + 管理者向けビデオ管理インターフェース

5. **プロジェクト管理**
   - ユーザーごとのプロジェクト作成・管理
   - プロジェクト進捗状況の可視化
   - プロジェクトの複製・アーカイブ機能
   - プロジェクト結果の保存・エクスポート機能

6. **AI支援機能**
   - ステップごとのAI支援対話
   - コンテキスト維持によるステップ間の連続性確保
   - プロンプトテンプレート管理とバージョニング
   - 何でも相談室機能によるフリーフォーム対話
   + **プロンプト構成要件**:
     + 過去のステップ成果物を要約してコンテキストとして活用
     + ステップの進行状況に応じた適切なプロンプト選択
     + ユーザーの対話履歴を考慮したメッセージ構成
     + システムプロンプトとユーザープロンプトの役割分担
   + **対話履歴管理要件**:
     + 複数ステップ間での対話コンテキスト維持
     + 長期対話履歴の効率的な保存と検索
     + トークン制限を考慮した重要情報の優先的保持
     + 対話セッションの再開と継続性の確保
   + **会話種別対応要件**:
     + 以下の会話種別に応じた最適なプロンプト選択とコンテキスト構築:
       + **開始時（Initial）**: ステップ開始時の導入と目的説明に特化
       + **継続時（Continuous）**: 対話の流れを維持し発展させる通常の会話
       + **チェック時（Checkpoint）**: 現在の成果物を評価し方向性を確認
       + **成果物作成時（OutputCreation）**: 最終成果物の作成と整形に特化
     + 会話種別に応じたコンテキスト量とトークン配分の最適化
     + 会話種別の自動判定と手動選択の両方をサポート
     + 将来的な会話種別の拡張に対応可能な柔軟な設計
   + **AIチャット対話インターフェース要件**:
     + リアルタイムの対話型インターフェース
     + メッセージタイプによる視覚的区別（システム/ユーザー/AIメッセージ）
     + 推論努力度（reasoning effort）の調整機能
     + フォントサイズ等の表示カスタマイズ機能
     + メッセージ送信中の適切なローディング表示
     + エラー発生時の回復機能と再試行オプション
     + 自動スクロールとスクロール位置管理
     + チャットリセット機能と確認ダイアログ
     + チャット履歴の保存と復元機能
     + チャット成果物のエクスポート機能

7. **サブスクリプション管理**
   - 複数サブスクリプションプランの設定
     - **管理者向け操作**:
       - サブスクリプションプランの新規作成、編集、削除
       - プランごとの価格、機能制限、利用可能なリソース上限などの設定
       - プラン一覧の管理
   - 支払い処理と履歴管理 (Stripe等の外部決済サービス連携)
     - 支払い成功/失敗時のハンドリングとユーザー通知
     - ユーザーによるサブスクリプション登録・変更・キャンセル処理
     - サブスクリプション成功/キャンセルページの表示
   - プラン別の機能制限制御

8. **成果物管理**
   - ステップごとのAI生成成果物の保存・管理
   - 成果物のバージョン管理とリビジョン履歴
   - 成果物のテンプレート適用とフォーマット変換
   - 成果物の統合によるビジネスプラン文書生成
   - 最終成果物のエクスポート（PDF、Word、HTMLなど）

9. **添付ファイル管理**
   - プロジェクト・ステップへのファイル添付
   - 様々なファイル形式のサポート（画像、PDF、Office文書など）
   - ファイルの保存・検索・取得機能
   - ファイルのバージョン管理と履歴追跡
   - ファイルサイズと数量の上限管理（プラン別）
   - 添付ファイルとAI対話の連携（ファイル内容の参照）

10. **国際化対応（i18n）機能**
   - 多言語ユーザーインターフェース（初期対応言語：日本語、英語）
   - 言語切り替え機能とユーザー設定保存
   - 日時、数値、通貨のロケール対応表示
   - 言語リソースの動的読み込みと効率的なバンドリング
   - 右左書き言語（RTL）のレイアウト対応（将来拡張用）
   - 言語非依存のUI設計（レイアウト崩れ防止）
   - 多言語コンテンツ管理システム
   - 言語固有のプロンプトテンプレート管理
   - ロケールに応じたAI出力の最適化
   - ユーザーの優先言語に基づいたコンテンツ提供

11. **歴史的事例学習によるリスク評価・改善提案機能**
   - 過去の成功・失敗事例データベースの構築と活用
   - ビジネスプランの自動リスク評価とスコアリング
   - 歴史的事例との類似性分析と成功確率予測
   - セクター・業界別の成功要因と失敗要因の分析
   - 具体的な改善提案と代替アプローチの提示
   - リスク要因の可視化と優先順位付け
   - 成功事例からの学習ポイント抽出と適用提案
   - シナリオ分析と「もし〜なら」シミュレーション
   - 時系列パターン分析による将来予測
   - 改善提案の実装難易度と期待効果の評価

12. **管理ダッシュボード** (新規項目)
    - 管理者向けの主要なシステム指標（ユーザー数、アクティブプロジェクト数、収益など）の概要表示
    - 各管理機能へのクイックアクセスリンク
    - システムアラートや通知の表示エリア

### 機能階層関係

以下の階層関係に基づいてコンテンツを構成します：

```
プログラム（コース）
  └── ステップ（学習・作業単位）
       ├── プロンプト（AI対話テンプレート）
       ├── 動画コンテンツ（補助学習材料）
       ├── 成果物（AIとの対話から生成される結果）
       └── 添付ファイル（ユーザーがアップロードした参考資料）
```

- 各プログラムは複数のステップで構成
- 各ステップには対応するプロンプト、補助動画コンテンツ、成果物、添付ファイルが紐づく
- ユーザーはプロジェクト内でプログラムのステップを進めながら学習・作業を進行

### ユーザー要件

**主要ユーザー層**:
- 起業家・新規事業担当者：体系的にビジネスプランを作成したい
- 中小企業経営者：事業拡大・新規事業計画を効率的に作成したい
- 事業コンサルタント：クライアント向けの提案書作成を効率化したい

**期待する価値**:
- AI支援による高品質なビジネスプラン作成の効率化（作成時間50%削減）
- ステップ形式による体系的なプラン構築
- 過去プロジェクトの再利用によるイテレーションの効率化
- 何でも相談室によるAI対話での疑問解決

## 非機能要件

### パフォーマンス要件

1. **レスポンスタイム**
   - 主要なAPIエンドポイント（例: プロジェクト一覧取得、AI対話応答）の平均レスポンスタイムは500ms未満であること。
   - 95パーセンタイルのレスポンスタイムは1000ms未満であること。

2. **スループット**
   - 通常時、システムは最低100リクエスト/秒を処理できること。
   - ピーク時（例: 複数ユーザーによる同時AI生成）、システムは最低50リクエスト/秒を処理できること。

3. **同時接続数**
   - システムは最低500人の同時接続ユーザーをサポートできること。

### スケーラビリティ要件

1. **水平スケーリング**
   - アプリケーションサーバー、データベース（リードレプリカ）は負荷に応じて水平スケーリング可能であること。サーバーレスコンポーネント（Vercel Functionsなど）を積極的に活用する。

2. **垂直スケーリング**
   - 必要に応じて、データベースインスタンスなどの垂直スケーリングが可能であること。

3. **負荷増加への対応**
   - ユーザー数やデータ量が現在の10倍に増加した場合でも、パフォーマンス要件を満たせるアーキテクチャであること。

### 可用性要件

1. **サービス稼働率**
   - システム全体の月間稼働率は99.9%以上を目指すこと。

2. **障害復旧**
   - 重大な障害発生時、システムは1時間以内に復旧可能であること（RTO: Recovery Time Objective）。

3. **データ損失**
   - システム障害発生時のデータ損失は最大5分以内であること（RPO: Recovery Point Objective）。定期的なデータベースバックアップとリストア手順を確立する。

### セキュリティ要件

1. **認証**
   - 安全な認証メカニズム（例: OAuth 2.0, JWT）を実装し、パスワードは適切にハッシュ化（例: bcrypt）して保存すること。Auth.js (NextAuth.js) の利用を推奨。

2. **認可**
   - 役割ベースのアクセス制御（RBAC）を実装し、ユーザーの権限に応じて機能へのアクセスを制限すること。必要に応じて、行レベルセキュリティ（RLS）の導入も検討する（特にマルチテナント機能実装時）。

3. **データ保護**
   - 通信経路（HTTPS）および保存データ（データベース暗号化）は暗号化すること。
   - 個人情報や機密データは適切にマスキングまたは匿名化すること。
   - OWASP Top 10などの一般的な脆弱性（SQLインジェクション、XSS、CSRFなど）に対する対策を講じること。

4. **依存関係のセキュリティ**
   - 使用するライブラリやフレームワークの脆弱性を定期的にスキャンし、必要に応じてアップデートすること（例: Dependabot, Snyk）。

5. **APIセキュリティ**
   - APIエンドポイントには適切な認証・認可、レート制限、入力値バリデーションを実装すること。

### 保守性要件

1. **コード品質**
   - [04_implementation_rules.md](./04_implementation_rules.md)で定義されたコーディング規約と命名規則を遵守すること。
   - コードには適切なコメントとドキュメント（JSDoc, TypeDoc）を付与すること。
   - コードの循環的複雑度（Cyclomatic Complexity）を低く保つこと。

2. **テスト**
   - 単体テスト、統合テスト、E2Eテストを実装し、主要な機能に対するテストカバレッジは80%以上を目指すこと。
   - テストはCI/CDパイプラインで自動実行されること。詳細は[09_testing_implementation.md](./09_testing_implementation.md)を参照。
   - **Storybook** を活用し、UIコンポーネントの分離開発、テスト、カタログ化を行うこと。

3. **モジュール性**
   - システムは関心事の分離に基づいて疎結合なモジュールで構成されること（クリーンアーキテクチャ、ドメイン駆動設計の原則に従う）。詳細は[02_architecture_design.md](./02_architecture_design.md)を参照。

4. **設定管理**
   - 環境変数や設定ファイルを用いて、環境ごとの設定を容易に管理できること。機密情報は安全な方法（例: Secret Manager）で管理すること。

5. **ログ記録**
   - アプリケーションの動作状況、エラー、セキュリティイベントなどを構造化ログとして記録し、監視・分析可能にすること。

### 運用性要件

1. **デプロイ**
   - CI/CDパイプラインを通じて、自動化された安全なデプロイプロセスを確立すること。詳細は[10_deployment_implementation.md](./10_deployment_implementation.md)を参照。

2. **監視**
   - システムのパフォーマンス（CPU、メモリ、レスポンスタイム）、エラー率、リソース使用状況などをリアルタイムで監視できること（例: Vercel Monitoring, Datadog, Sentry）。

3. **アラート**
   - システムの異常（エラー率の急増、パフォーマンス低下など）を検知し、運用チームに迅速に通知する仕組みを構築すること。

4. **バックアップとリストア**
   - 定期的なデータベースバックアップと、迅速かつ確実にリストアできる手順を確立・テストすること。

### 技術スタック選定に関する要件

- **フレームワーク**: フロントエンドおよびバックエンドの主要フレームワークとしてNext.js (App Router) を採用する。React Server Components (RSC) と Client Components を適切に使い分ける。
- **言語**: TypeScriptを主要な開発言語とする。型安全性を最大限に活用する。
- **データベース**: リレーショナルデータベースとしてPostgreSQLを採用する。
- **ORM (Object-Relational Mapper)**: **Drizzle ORM** を主要な ORM として採用する。型安全性、パフォーマンス、マイグレーション機能を提供する Drizzle Kit を活用する。データベーススキーマ定義、クエリビルディング、マイグレーション管理は Drizzle の機能を中心に行う。
- **UIコンポーネント**: Shadcn/UI と Tailwind CSS をベースとしたUIコンポーネントライブラリを使用し、一貫性のあるデザインシステムを構築する。アクセシビリティ（a11y）要件を満たすこと。
- **コンポーネント開発・ドキュメンテーション**: **Storybook** を導入し、UIコンポーネントのカタログ化、分離開発、インタラクティブなドキュメンテーションを実現する。
- **状態管理**: クライアントサイドの状態管理には、サーバーキャッシュ管理として TanStack Query (React Query)、シンプルなグローバル状態管理として Jotai または Zustand、Context API をユースケースに応じて使い分ける。
- **テスト**: Vitest を主要なテストランナーとし、React Testing Library をコンポーネントテストに使用する。E2Eテストには Playwright または Cypress を検討する。
- **CI/CD**: GitHub Actions または Vercel Deployments を使用して CI/CD パイプラインを構築する。
- **インフラストラクチャ**: Vercel を主要なホスティングプラットフォームとして利用する。データベースは Supabase または AWS RDS/Aurora Serverless v2 などのマネージドサービスを利用する。

### エラーハンドリング要件

1. **エラーの分類**
   - エラーはドメインエラー、アプリケーションエラー、インフラストラクチャエラーなどに分類し、構造化されたエラーオブジェクトを使用する。詳細は[05_type_definitions.md](./05_type_definitions.md)を参照。

2. **ユーザーへのフィードバック**
   - フロントエンドでは、ユーザーフレンドリーなエラーメッセージを表示し、技術的な詳細（スタックトレースなど）は公開しない。

3. **ログ記録**
   - すべての捕捉されたエラーおよび未捕捉例外は、詳細なコンテキスト情報（リクエスト情報、ユーザー情報、スタックトレース）とともにログに記録されること。

4. **回復力**
   - 可能な限り、部分的障害がシステム全体の停止につながらないように設計すること（例: サーキットブレーカーパターン）。

5. **一貫性**
   - 関数やメソッドの戻り値として、成功/失敗を明確に示す方法（例: `Result` 型、`neverthrow` ライブラリの活用）を推奨する。詳細は[04_implementation_rules.md](./04_implementation_rules.md)を参照。

### エラーハンドリング要件（重複削除）

- **エラーの分類**: エラーはドメインエラー、アプリケーションエラー、インフラストラクチャエラーなどに分類し、構造化されたエラーオブジェクトを使用する。詳細は[05_type_definitions.md](./05_type_definitions.md)を参照。
- **ユーザーへのフィードバック**: フロントエンドでは、ユーザーフレンドリーなエラーメッセージを表示し、技術的な詳細（スタックトレースなど）は公開しない。
- **ログ記録**: すべての捕捉されたエラーおよび未捕捉例外は、詳細なコンテキスト情報（リクエスト情報、ユーザー情報、スタックトレース）とともにログに記録されること。
- **回復力**: 可能な限り、部分的障害がシステム全体の停止につながらないように設計すること（例: サーキットブレーカーパターン）。
- **一貫性**: 関数やメソッドの戻り値として、成功/失敗を明確に示す方法（例: `Result` 型、`neverthrow` ライブラリの活用）を推奨する。詳細は[04_implementation_rules.md](./04_implementation_rules.md)を参照。

## 技術選定

### フロントエンド

- **フレームワーク**: Next.js (React 18+)
  - SSR、SSG、CSRの柔軟な利用によるパフォーマンス最適化
  - Vercelへのデプロイを最適化しつつ、他プラットフォームへの移行も可能な構成
- **状態管理**: React Context API + TanStack Query
- **スタイリング**: Tailwind CSS + shadcn/ui
- **型システム**: TypeScript（厳格モード）
- **フォント**: 英語にHanken Grotesk、日本語にNoto Sans JPを使用

### バックエンド

- **言語/ランタイム**: Node.js v22 LTS ("Jod")
- **API実装**: Next.js API Routes
  - 小〜中規模のバックエンドロジックを同一プロジェクト内で管理
- **データベース**: PostgreSQL（Supabaseで提供）
  - Row Level Securityによるデータアクセス制御
  - UUIDを主キーとしたセキュアなID管理
- **ORM/データアクセス層**: Drizzle ORM
- **認証**: Auth.js
  - OAuth2+OIDCプロバイダー統合
- **ストレージ**: 
  - **プライマリ**: Vercel Blob Storage
  - **代替/補完**: Supabase Storage
- **リアルタイム機能**: Supabase Realtime / Pusher
- **キャッシュ**: Upstash Redis（Vercel統合）
- **依存性注入**: tsyringe

### AI統合

- **主要AI**: 複数AIモデルの抽象化レイヤー
  - **サポート対象モデル**:
    - OpenAI GPTシリーズ (GPT-4o、GPT-o3-mini等)
    - Anthropic Claudeシリーズ (Claude 3 Opus、Sonnet、Haiku等)
    - Google Geminiシリーズ (Gemini Pro、Ultra等)
    - オープンソースモデル (Llama、Mistral等) ※自己ホスティング対応
  - **モデル選択ロジック**:
    - ユーザー設定に基づく明示的な選択
    - タスク種別に応じた最適モデルの自動選択
    - コスト・パフォーマンス要件に基づくモデル選定
    - フォールバック戦略によるサービス継続性確保
- **ベクトルDB**: PostgreSQLのpgvector拡張（Supabaseで提供）

### インフラストラクチャ

- **ホスティング**: Vercel（プライマリ環境）
- **CI/CD**: Vercel GitHub連携 + GitHub Actions
- **モニタリング**: Vercel Analytics + 必要に応じて追加ツール
- **CDN**: Vercelエッジネットワーク

具体的な実装詳細とアーキテクチャの適用方法については、「02_architecture_design.md」に記載しています。技術スタックの採用理由、代替案検討、各層での具体的な実装パターンなどは、アーキテクチャ設計ドキュメントを参照してください。

### 環境分離戦略

- **開発環境**:
  - ローカル開発環境: Supabase CLI + ローカルエミュレーター
  - 共有開発環境: 開発用Supabaseプロジェクト + Vercel開発環境
- **テスト/ステージング環境**:
  - テスト専用Supabaseプロジェクト
  - Vercelプレビュー環境（Pull Request連携）
  - E2Eテスト用の独立環境
- **本番環境**:
  - 本番用Supabaseプロジェクト（Pro/Teamプラン推奨）
  - Vercel本番環境（Production）
  - 緊急対応用の本番スタンバイ環境（オプション）
- **環境間データ移行**:
  - Supabase CLIとMigration機能によるスキーマ同期
  - 環境変数管理: Vercel Environment Variables + .env.localファイル
  - シード/テストデータの管理とリフレッシュ戦略

**ブランチ戦略と環境の対応**:

```
各開発ブランチ → development → release → main
    |               |             |         |
    v               v             v         v
 開発作業        開発環境     ステージング環境  本番環境
(ローカル)     (Vercel Preview)  (Vercel Staging)  (Vercel Production)
```

詳細なブランチ戦略と環境構成については「02_architecture_design.md」を参照してください。

## 開発体制・スケジュール

### チーム構成

- **プロジェクトマネージャー**：1名（進行管理、要件調整）
- **フロントエンド開発者**：2名（UI/UX実装、状態管理）
- **バックエンド開発者**：2名（API設計、ビジネスロジック実装）
- **データベーススペシャリスト**：1名（データモデリング、パフォーマンス最適化）
- **DevOpsエンジニア**：1名（CI/CD、インフラ構築）
- **QAエンジニア**：1名（テスト設計、自動化）

### マイルストーン

1. **フェーズ1：設計・アーキテクチャ（6週間）**
   - 要件定義完了：1週間
   - アーキテクチャ設計：2週間
   - データモデル設計：2週間
   - 技術検証（PoC）：1週間
     - Next.jsのSSR/SSG/CSRパフォーマンス検証
     - Auth.js認証システム検証
     - Drizzle ORMとPostgreSQL連携の確認

2. **フェーズ2：コア実装（12週間）**
   - 基盤コード構築：2週間
     - Next.jsプロジェクト設定
     - API Routesの基本構造設計
     - ルーティング体系の確立
   - OAuth2+OIDC認証システム：2週間
     - Auth.jsによる認証基盤実装
     - SSO対応のIdP連携設計
   - PostgreSQLデータベース実装：2週間
     - Drizzle Kitによるマイグレーション設定
     - PostgreSQL スキーマ最適化
     - インデックス戦略と性能最適化
   - 基本API実装：3週間
     - Next.js API Routesによるバックエンド実装
     - 外部APIとの連携インターフェース設計
   - フロントエンド基盤実装：3週間
     - コンポーネント設計（shadcn/ui活用）
     - レスポンシブデザイン実装
     - 状態管理パターン確立

3. **フェーズ3：機能実装（14週間）**
   - ユーザー管理機能：2週間
   - プログラム・ステップ管理機能：3週間
   - プロンプト・コンテンツ管理：2週間
   - プロジェクト管理機能：2週間
   - AI統合機能：3週間
     - Next.js API Routes内での各種LLM API連携
     - pgvectorまたは専用ベクトルDBを使用したコンテキスト管理
   - サブスクリプション管理：2週間

4. **フェーズ4：品質保証・最適化（8週間）**
   - 単体・統合テスト：3週間
   - E2Eテスト自動化：2週間
   - パフォーマンス最適化：2週間
     - Next.jsのビルド最適化
     - CDNとキャッシュ戦略の実装
     - APIレスポンス時間改善
   - セキュリティレビュー：1週間

5. **フェーズ5：リリース準備（4週間）**
   - ドキュメント整備：1週間
   - 最終UAT：1週間
   - 本番環境構築：1週間
     - Vercel本番環境の構築と設定最適化
     - Supabase本番プロジェクトの設定とデータ移行
     - バックアップと障害復旧手順の確認
   - リリース準備・リハーサル：1週間

## 開発ガイドライン

### コーディング規約

- **一般原則**
  - SOLID原則の遵守
  - DRYとYAGNIの適切なバランス
  - 単一責任の原則に基づくモジュール設計
  - ドメイン駆動設計（DDD）の適用
    - ビジネスロジックとインフラロジックの明確な分離
    - ドメインモデルを中心とした設計（詳細は02_architecture_design.mdに記載）
    - ユビキタス言語の一貫した使用

- **Next.js開発規約**
  - app/ ディレクトリ構造を採用（pages/ ではなく）
  - サーバーコンポーネントとクライアントコンポーネントの明確な分離
  - データフェッチングはサーバーコンポーネントで実行
  - クライアント状態管理はコンポーネントを 'use client' 指定
  - ルート（Route）ごとのレイアウト設計
  - API Routesは機能ドメイン別にグループ化

具体的なコーディング規約、命名規則、ディレクトリ構造については「04_implementation_rules.md」を参照してください。

### 品質保証

- **テストカバレッジ**
  - ユニットテスト：Jest による80%以上のカバレッジ
  - 統合テスト：主要フロー100%カバレッジ
  - E2Eテスト：Cypressによる重要ユーザージャーニーのカバレッジ
  - Next.jsのサーバーコンポーネントとAPI Routesのテスト方法標準化

- **コードレビュー**
  - プルリクエストベースの開発
  - コードレビューチェックリスト
  - 静的解析ツールの活用（ESLint, SonarQube等）
  - Next.jsのlintルールによる追加チェック

- **パフォーマンステスト**
  - Lighthouse/Web Vitalsスコア測定
  - Next.jsビルド分析とバンドルサイズ最適化
  - サーバーレス関数の実行時間とコールドスタート分析
  - OpenTelemetryベースの統合アプリケーション監視システム
  - Prometheus、Grafana、Datadogなど主要監視ツールとの連携

### ドキュメント管理

- **コード内ドキュメント**
  - クラス・関数のJSDocコメント必須
  - パブリックAPIのOpenAPI仕様書
  - TypeDocによるAPI自動ドキュメント生成
  - Next.jsレイアウトとページの責任範囲を明記

- **アーキテクチャドキュメント**
  - C4モデルでのアーキテクチャ図作成
  - ADR（Architecture Decision Records）による決定記録
  - データモデル図（ERD）
  - Next.js App Router構造の可視化
  - データアクセスパターンと最適化戦略の文書化

- **運用ドキュメント**
  - マルチクラウド対応デプロイフロー手順書
  - 環境別設定（開発・ステージング・本番）管理ガイド
  - クラウド間移行の考慮点と手順
  - PostgreSQL環境管理とバックアップ・復旧手順
  - 監視・アラート設定ガイド（各クラウドプロバイダー対応）
  - 障害対応手順書

## プロジェクト管理・進め方

### 開発手法

- **アジャイル開発（スクラム）**
  - 2週間単位のスプリント
  - デイリースタンドアップ（15分）
  - スプリントレビュー・振り返り

- **継続的インテグレーション/デプロイ（CI/CD）**
  - Vercel GitHub連携による自動デプロイ（プライマリ）
  - 必要に応じてGitHub Actions / GitLab CIによる追加ワークフロー
  - マルチ環境デプロイ（開発・ステージング・本番）
  - ブランチ戦略：GitHub Flow
  - 自動テスト実行と品質ゲート
  - Vercelのプレビュー環境を活用した検証プロセス

### コミュニケーション方法

- **ドキュメント管理**
  - GitHubリポジトリ内でのMarkdownドキュメント管理
  - JIRA/GitHub Projectsでのタスクトラッキング
  - Confluenceでの知識ベース構築

- **ミーティング体制**
  - デイリースタンドアップ：毎日10:00-10:15
  - スプリント計画：隔週月曜日13:00-16:00
  - 振り返り：隔週金曜日15:00-17:00
  - 技術検討会：毎週水曜日13:00-14:00

- **ツール**
  - 開発環境：
    - Cursor：AIアシスト機能を活用した効率的なコーディング
    - GitHub：ソースコード管理・PRレビュー・イシュートラッキング
    - GitHub Actions：CI/CD自動化
  - コミュニケーション：
    - Slack：デイリーコミュニケーション
    - Figma：UIデザイン管理
    - Miro：コラボレーションボード 

### プロトタイプ開発の位置づけ

技術検証（PoC）フェーズでは、核となる技術要素の実現可能性を検証し、アーキテクチャ設計の妥当性を確認します。プロトタイプから得られた知見は以下の形で本実装に反映されます：
- アーキテクチャ設計の調整と最終化
- 実装パターンの確立と標準化
- 技術的リスクの早期発見と対策立案
- パフォーマンスボトルネックの特定と改善戦略策定
- ユーザー体験設計の検証と改善

プロトタイプ開発は、本格的な実装開始前のリスク低減策として位置づけられ、実装フェーズでの手戻りを最小化することを目的としています。特に技術スタックの統合検証とAI対話機能の実装パターンの確立は、プロジェクト全体の成功に直結する重要な要素と位置づけています。

### リスク管理

プロジェクト実行にあたり以下の主要リスクを認識し、対策を講じます：

1. **技術的リスク**
   - **DDD+ヘキサゴナルアーキテクチャの適用課題**
     - リスク：Next.js環境でのクリーンアーキテクチャ実装の複雑さ
     - 対策：プロトタイプでのパターン検証と早期ガイドライン策定
   - **AI APIの安定性と応答速度**
     - リスク：各種LLM APIの障害や応答遅延によるユーザー体験低下
     - 対策：堅牢なリトライ戦略とフォールバックメカニズムの実装
   - **型安全性と開発効率のバランス**
     - リスク：過度な型定義による開発速度低下
     - 対策：共通型ユーティリティの整備と適切な抽象化レベルの設定

2. **スケジュールリスク**
   - **複雑機能の実装遅延**
     - リスク：AI対話やステップ管理など複雑機能の実装遅れ
     - 対策：MVPアプローチと段階的機能リリース戦略の採用
   - **チーム編成変更の影響**
     - リスク：開発途中のリソース変更による知識損失
     - 対策：適切な知識共有とドキュメント整備、ペアプログラミングの推奨
   - **外部依存サービスの仕様変更**
     - リスク：各種LLM APIなど外部サービスの予期せぬ変更
     - 対策：抽象化レイヤーの導入と複数プロバイダー対応の設計

3. **品質リスク**
   - **パフォーマンス要件の達成度**
     - リスク：複雑なデータ処理による応答時間の悪化
     - 対策：早期からのパフォーマンス測定と最適化、キャッシュ戦略の実装
   - **セキュリティ要件の完全実装**
     - リスク：RLSとアプリケーションロジックの適切な分離の失敗
     - 対策：セキュリティレビューの実施とペネトレーションテストの導入
   - **ユーザー体験の一貫性**
     - リスク：各機能間のUX不整合によるユーザー混乱
     - 対策：デザインシステムの確立と定期的なユーザビリティテスト実施 

### 国際化・多言語対応要件

1. **UIの国際化**
   - すべてのUIテキストの外部化とリソースバンドル管理
   - 言語リソースの遅延読み込みによるパフォーマンス最適化
   - 複数言語でのUI検証とレイアウトテスト
   - 非ASCII文字セットの完全サポート
   - 文字列結合ではなくフォーマット文字列を使用した翻訳対応

2. **コンテンツの多言語対応**
   - 複数言語でのプロンプトテンプレート管理
   - 言語固有のAI調整パラメーター設定
   - 多言語コンテンツのバージョン管理と同期
   - 機械翻訳APIとの統合による翻訳支援機能
   - 翻訳作業フローとレビュープロセスの確立

3. **ローカライゼーション品質**
   - 各言語の文化的コンテキストに適応したUI/UX
   - 専門用語の多言語対応用語集の整備
   - 翻訳品質の自動検証と一貫性チェック
   - 定期的な言語リソース更新プロセス
   - 現地ユーザーによるレビューと品質評価

4. **開発者体験**
   - i18n機能のモジュール化と再利用性
   - 開発環境での言語切り替え容易性
   - 新言語追加時の開発プロセス効率化
   - 翻訳キーの自動抽出と未翻訳検出
   - 翻訳リソースの静的解析による整合性確認

### リスク評価・改善提案品質要件

1. **データ品質**
   - 多様な産業・セクターからの事例収集（最低500事例）
   - 事例データの定期的な更新と拡充（四半期ごと）
   - データソースの信頼性と出典の明確な記録
   - 構造化データと非構造化データの統合分析
   - 時代的バイアスを考慮したデータ重み付け

2. **分析精度**
   - リスク評価の適合率と再現率：80%以上
   - 成功確率予測の平均絶対誤差：15%以内
   - 改善提案の実用性評価：ユーザー評価4/5以上
   - 事例間の関連性分析の精度：75%以上
   - 業界固有の成功・失敗パターン識別率：85%以上

3. **出力品質**
   - リスク評価レポートの理解容易性
   - 改善提案の具体性と実行可能性
   - 視覚的なリスクダッシュボードの情報密度
   - 自然言語による説明の明瞭さ
   - 改善提案のカスタマイズ性と状況適応性

4. **システム性能**
   - リスク評価処理時間：3秒以内
   - 大規模事例分析の応答時間：5秒以内
   - 事例データベースの検索最適化
   - リアルタイム分析とバッチ処理の適切な使い分け
   - システム負荷の変動に対する弾力的なリソース割当

これらのエラーハンドリング要件は、AIを活用したサービスの信頼性と回復力を確保し、ユーザー体験の一貫性を維持するために重要です。特に各種LLM APIへの依存性を考慮し、APIの不安定性や応答遅延に対する堅牢な対策を講じる必要があります。 