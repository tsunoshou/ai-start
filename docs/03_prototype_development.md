# プロトタイプ/PoC開発

最終更新日: 2025-03-26

## 本ドキュメントの目的

このドキュメントは、AiStartの核となる機能のプロトタイプ開発に関する計画と検証事項を定義しています。関連ドキュメントとの役割の違いは以下のとおりです：

- **01_requirements_definition.md**：「何を」実現するのか（What）

  - ビジネス・機能要件の定義
  - 非機能要件の定義
  - 技術スタックの概要

- **02_architecture_design.md**：「どのように」実現するのか（How）

  - アーキテクチャスタイルの選定と理由
  - ディレクトリ構造と各レイヤーの責務
  - モジュール分割と依存関係の設計
  - 認証・認可の実装アーキテクチャ
  - エラー処理戦略の詳細

- **03_prototype_development.md**：プロトタイプでの検証事項（Verify）

  - プロトタイプの目的と検証内容
  - 検証する技術項目と評価方法
  - プロトタイプの実装範囲と制限

- **04_implementation_rules.md**：「どのように書くか」（Write）
  - 具体的なコーディング規約と命名規則
  - 実装パターン集と具体的なコード例
  - 型定義と安全な変換関数の実装詳細
  - リポジトリパターンとRLSの実装詳細

このドキュメントではプロトタイプ開発を通じて検証すべき技術項目と評価方法を定義し、本実装に向けた知見を収集します。プロトタイプ開発の成果は、02_architecture_design.mdの改良と04_implementation_rules.mdの具体化に活用されます。

## アーキテクチャ検証の対応関係

このプロトタイプ開発では、02_architecture_design.mdで定義されたアーキテクチャの主要コンポーネントを検証します。主な対応関係は以下の通りです：

| プロトタイプ検証項目    | 対応するアーキテクチャ要素                                                  |
| ----------------------- | --------------------------------------------------------------------------- |
| DDD実装パターン         | 02_architecture_design.md「アーキテクチャ概要」「モジュール分割・依存関係」 |
| リポジトリパターンとRLS | 02_architecture_design.md「セキュリティ設計」「データフロー・インフラ構成」 |
| Next.js App Router活用  | 02_architecture_design.md「Next.js App Router統合」                         |
| AI対話システム          | 02_architecture_design.md「AIサービス層の設計」「エラー処理戦略」           |

このプロトタイプでは、02_architecture_design.mdの推奨ディレクトリ構造を簡略化して実装しますが、基本的なレイヤー分離（ドメイン、アプリケーション、インフラ、プレゼンテーション）は維持します。

## スコープ限定

### 対象機能

本PoCでは、AiStartの核となる機能のうち、特に技術的検証が必要な以下の機能に焦点を当てます：

1. **AI対話とプロンプト管理機能**

   - OpenAI APIを活用したAI対話システムの実装
   - プロンプトテンプレートの管理とバージョニング
   - コンテキスト維持によるステップ間の対話連続性確保

2. **ステップ管理と進捗トラッキング**

   - ステップの順序と依存関係の設定
   - 条件分岐型ステップフローの実装
   - 進捗状態の永続化と復元

3. **国際化（i18n）機能の基盤検証**

   - 多言語対応の基本フレームワーク設定
   - 日英バイリンガル対応の実装パターン検証
   - コンポーネントの国際化対応
   - API応答の多言語対応メカニズム

4. **歴史的事例分析システムの基礎検証**
   - 事例データベースの構造設計と初期データ投入
   - 基本的な類似性検索と評価アルゴリズムの検証
   - リスク評価と改善提案の基本フロー実装
   - AI生成による改善提案の質の検証

これらの機能は、AiStartの中核機能であり、技術的な実現可能性とパフォーマンスを検証する必要があります。特に、AIとの対話を通じたビジネスプラン作成のユーザー体験を早期に検証することが重要です。

### 実装範囲の制限

以下の要素は本PoCでは簡略化または省略します：

- **認証・認可**: Auth.jsの基本的なセットアップのみ実装し、高度なRBAC機能は省略
- **サブスクリプション管理**: 支払い機能は実装せず、フラグによる機能制限のみシミュレート
- **UI/UXの完成度**: 基本的な機能性のみに焦点を当て、デザインの細部は省略
- **添付ファイル管理**: ファイルアップロード基本機能のみ実装し、バージョン管理は省略
- **マルチ環境対応**: 開発環境とステージング環境のみ構築し、本番環境の詳細設定は省略
- **多言語対応の範囲**: 日本語と英語の2言語のみ対応し、他言語対応やRTL対応は省略
- **事例データベースの規模**: 限定的な事例データ（50-100件程度）での検証に留める
- **分析アルゴリズムの精緻化**: 基本的な類似性分析と単純なスコアリングモデルに限定

本PoCでは技術スタックの検証と主要機能のフローを確立することに集中し、システムの技術的な基盤を確立することを優先します。

## PoCの目的・評価基準

### 技術検証項目

1. **アーキテクチャの検証**

   - DDDベースのヘキサゴナルアーキテクチャの実装容易性と保守性
   - Next.js App Router環境での層分離の実現方法
   - エンティティとDTO間のマッピング戦略の効率性

2. **データベース技術の検証**

   - PostgreSQL + Drizzle ORMの実装パターンの効率性
   - Supabase RLSの実装と安全性
   - リポジトリパターンとORMの統合方法の評価

3. **AI統合の検証**

   - OpenAI API呼び出しのパフォーマンスと安定性
   - ストリーミングレスポンスの実装と最適化
   - コンテキスト管理とプロンプトエンジニアリングの実効性

4. **Next.jsの新機能検証**

   - App Routerの実装パターンとレンダリング戦略
   - サーバーコンポーネントとクライアントコンポーネントの分離戦略
   - Server Actionsの活用可能性

5. **国際化（i18n）技術の検証**

   - next-intlの実装パターンと最適化手法
   - SSRおよびCSRにおける多言語対応の実装評価
   - 言語リソース管理と動的読み込みの効率性
   - 翻訳キーの型安全な管理と開発者体験の改善

6. **歴史的事例分析技術の検証**
   - pgvectorを活用した類似性検索のパフォーマンス
   - 事例データ構造とインデックス設計の最適化
   - 分析アルゴリズムの精度と計算コスト
   - AI提案生成の品質とコンテキスト理解度

### 評価基準

1. **パフォーマンス基準**

   - API応答時間: 通常のAPI呼び出しが150ms以内、AI統合APIが3秒以内
   - 初回ページロード: 1.5秒以内
   - AI対話の応答時間: ストリーミングによる即時開始（300ms以内）

2. **開発効率基準**

   - コード重複率: 20%未満
   - コンポーネント再利用率: 70%以上
   - 機能追加時の変更影響範囲: 関連モジュールのみに限定

3. **技術適合性基準**

   - チーム内でのDDD理解度: 80%以上
   - アーキテクチャ準拠率: レビュー時に90%以上
   - ドキュメントとコードの一致率: 95%以上

4. **国際化実装基準**

   - 言語切り替え時のパフォーマンス: 200ms以内
   - リソースバンドルサイズ: 言語あたり100KB以下
   - 翻訳カバレッジ: プロトタイプUIの95%以上
   - 開発者効率: 新規コンポーネントの国際化対応に要する時間10分以内

5. **事例分析システム基準**
   - 分析レスポンス時間: 3秒以内
   - 類似事例の関連性スコア: 手動評価で0.7以上
   - 改善提案の具体性・実用性: ユーザーテストで3.5/5以上
   - システムリソース使用量: CPU/メモリ使用量の最適化

### 主要検証テストと成功基準

以下の具体的なテストを実施し、プロトタイプの成功を判断します：

1. **DDDレイヤー分離テスト**

   - ドメインロジックの変更がインフラ層に影響しないことを検証
   - インフラ実装の変更（例：DB→モック）がドメインロジックに影響しないことを確認
   - 成功基準：レイヤー間の依存方向が100%内向きであること

2. **Next.js App Routerテスト**

   - サーバーコンポーネントとクライアントコンポーネントの適切な分離
   - 集約された状態管理でのデータフェッチの効率性
   - 成功基準：不要なクライアントレンダリングの回避、データの重複取得がないこと

3. **AI対話フローテスト**

   - 複数ターンの会話でのコンテキスト維持
   - エラー発生時の自動リカバリー動作
   - 成功基準：10ターン以上の対話でコンテキストが維持され、3種類のエラーから正常に回復すること

4. **RLS実効性テスト**

   - 異なるユーザーロール間でのデータアクセス分離
   - リポジトリ層でのクエリ効率
   - 成功基準：アクセス権限外のデータ漏洩が0件、権限チェック時のオーバーヘッドが10%未満

5. **国際化実装テスト**

   - 言語切り替えによるUI更新の一貫性
   - 日英両言語でのレイアウト安定性
   - サーバーコンポーネントとクライアントコンポーネント間での言語状態維持
   - 成功基準：両言語での同等のユーザー体験、パフォーマンス劣化なし

6. **事例分析システムテスト**
   - 複数の業種・規模のビジネスプランに対する分析精度
   - 改善提案の具体性と実用性の評価
   - 分析結果の説明可能性と根拠提示
   - 成功基準：テストケースの80%以上で適切なリスク識別と有用な改善提案の生成

### リスク検証項目

1. **技術的リスク**

   - DDD+ヘキサゴナルアーキテクチャがNext.js環境で適切に実装できるか
   - TypeScriptの型安全性を損なわずにレイヤー間の疎結合を実現できるか
   - Supabase RLSとドメインロジックの適切な分離が可能か
   - AI対話のストリーミングレスポンスが安定して実装できるか

2. **パフォーマンスリスク**

   - Next.jsのSSRとApp Routerが大規模アプリケーションで十分なパフォーマンスを発揮するか
   - Drizzle ORMが複雑なクエリに対して十分に最適化できるか
   - AI対話のコンテキスト管理がメモリ使用量とパフォーマンスに与える影響

3. **開発効率リスク**

   - 新しいアーキテクチャの学習曲線がチームの開発速度に与える影響
   - DDDアプローチが開発工数を増加させないか
   - 型定義の複雑化がメンテナンス性に影響を与えないか

4. **国際化関連リスク**

   - 多言語対応によるバンドルサイズとパフォーマンスへの影響
   - 翻訳管理の運用負荷と保守性
   - RTL対応の将来的な実装難易度
   - 国際化によるUI設計の制約と複雑化

5. **事例分析システムリスク**
   - 十分な質と量の事例データ収集の実現可能性
   - 分析アルゴリズムの精度と計算コストのトレードオフ
   - AI提案生成のコンテキスト理解と具体性のバランス
   - 事例データベースの成長に伴うパフォーマンス維持

## ビジネス要件検証

プロトタイプでは技術的検証に加え、以下のビジネス要件の実現可能性も検証します：

1. **ユーザー体験の検証**

   - AI対話のレスポンス品質と応答時間がユーザー満足度に与える影響
   - ステップ形式によるビジネスプラン作成の効率化効果の予備測定
   - 会話種別の切り替えがユーザー作業効率に与える影響
   - 対話コンテキスト管理の効果とユーザーの連続作業感への寄与

2. **価値提案の検証**

   - AI支援によるビジネスプラン作成時間の短縮効果（目標：従来比50%削減）
   - 成果物の品質向上効果の定性的評価
   - 条件分岐型ステップフローによる柔軟なプラン作成の可能性
   - ステップ間での対話コンテキスト維持による作業継続性の向上効果

3. **ビジネスプロセスの検証**

   - プログラム（コース）構成の柔軟性とコンテンツ管理の効率性
   - プロジェクト管理機能の使いやすさと実用性
   - 成果物の保存・エクスポート機能のユースケース適合性
   - AIプロンプト管理の運用負荷と効果のバランス

4. **国際化のビジネス価値検証**

   - 多言語対応による市場拡大効果の予備評価
   - 日英バイリンガル対応の運用コストと効果のバランス
   - ユーザーの言語切り替え行動パターンの調査
   - 言語固有の機能要求の特定とロードマップ策定

5. **事例分析機能の価値検証**
   - リスク評価の信頼性とユーザー受容度
   - 改善提案の具体性と実用性に対するユーザー評価
   - 成功確率予測の信頼性と意思決定への影響
   - 提案に基づく実際のビジネスプラン改善効果の初期評価

ビジネス要件の検証結果は、本実装での機能優先順位付けや、UXデザインの改善、マーケティングメッセージの構築に活用します。

## プロトタイプ開発計画

### スケジュールと作業項目

01_requirements_definition.mdで定義したフェーズ1の「技術検証（PoC）：1週間」に相当する作業計画です。以下のタイムラインに従ってプロトタイプ開発を行います。

| 週    | 日数  | 作業項目                             | 成果物                                |
| ----- | ----- | ------------------------------------ | ------------------------------------- |
| 1週目 | 1-2日 | 開発環境セットアップと基盤コード構築 | Next.jsプロジェクト、Supabase接続設定 |
|       | 1-2日 | AIプロバイダー統合実装と検証         | マルチプロバイダー対応AI統合レイヤー  |
|       | 1日   | 国際化基盤実装と検証                 | 多言語リソース管理システム            |
|       | 1-2日 | 歴史的事例分析エンジン基本実装       | 事例データベースと分析ロジック        |

### マイルストーン

1. **環境構築完了**（1日目）

   - Next.jsプロジェクト初期化
   - Supabase/PostgreSQL環境設定
   - CI/CD基本設定

2. **コア機能プロトタイプ完成**（3日目）

   - AI対話基本機能動作確認
   - 多言語切替基本機能確認
   - データモデル検証

3. **技術検証完了**（5日目）
   - 各検証項目の評価完了
   - 問題点と対策の文書化
   - 本実装に向けた設計・アーキテクチャ調整

### プロトタイプからの知見反映

プロトタイプで得られた知見は、以下のドキュメントに反映します：

1. **02_architecture_design.md**

   - AI統合レイヤーの詳細設計調整
   - 国際化対応アーキテクチャの詳細化
   - 歴史的事例分析システムのデータフロー最適化

2. **04_implementation_rules.md**

   - プロジェクト全体の命名規則の確定
   - 実装パターンの選定と標準化
   - エラーハンドリング戦略の具体化

3. **05_type_definitions.md**

   - 型定義の整理と最適化
   - ドメインモデルの詳細化
   - スキーマ定義の最終化

4. **リスク管理計画**
   - 特定された技術的リスクへの対応策
   - 開発期間見積もりの調整
   - 必要なリソースの再評価

## 実装方針

### 技術スタック

**フロントエンド**

- Next.js 14（App Router）
- React 18
- TypeScript 5.3+
- TanStack Query（データフェッチング）
- Tailwind CSS + shadcn/ui（基本UIコンポーネント）
- Lucide React（アイコン）

**バックエンド**

- Next.js API Routes
- Drizzle ORM（PostgreSQLクエリビルダー）
- Zod（バリデーション）

**データベース**

- PostgreSQL（Supabase提供）
- Row Level Security (RLS)
- pgvector（ベクトル検索）

**認証**

- Auth.js（基本認証）

**API統合**

- OpenAI API Client
- Upstash/Redis（レート制限とキャッシュ）

**デプロイ**

- Vercel（フロントエンド/バックエンド）
- Supabase（データベース）

### 簡略化する部分

1. **UI/UXデザイン**

   - 最低限の機能性を持つUIを実装
   - 高度なアニメーションやインタラクションは省略
   - shadcn/uiのデフォルトコンポーネントを主に活用

2. **認証・認可**

   - Auth.jsの基本セットアップのみ実装
   - 詳細なRBAC機能は未実装
   - サービスアカウントとテストユーザーのみで検証

3. **エラーハンドリング**

   - 基本的なエラーハンドリングのみ実装
   - 本番環境用の詳細なロギングや回復機能は省略

4. **グローバリゼーション**

   - 日本語と英語の2言語のみ対応
   - その他の多言語対応機能は未実装

5. **監視・ロギング**
   - 最小限の開発用ロギングのみ実装
   - 本格的な監視システムは未統合

### 検証に集中する部分

1. **ドメイン駆動設計の実装パターン**

   - エンティティとValueObjectの定義と使用法
   - リポジトリインターフェースと実装の分離
   - ユースケースによるビジネスロジックの実装
   - 集約境界の定義と実装

2. **Next.js App Routerの活用法**

   - サーバーコンポーネントとクライアントコンポーネントの分離戦略
   - 適切なルート構造とレイアウト設計
   - Server Actionsによるデータ操作
   - データフェッチングとキャッシュ戦略

3. **AI対話システムの実装**

   - ストリーミングレスポンスの最適実装
   - コンテキスト管理の効率的な実装
   - プロンプトエンジニアリングの効果検証
   - コンテキスト消費を最小化する戦略
   - プロンプトテンプレートとステップ情報の統合プロセス
   - 成果物要約とメッセージ構成の最適パターン
   - 対話履歴の効率的な管理と活用方法

4. **リポジトリパターンとRowLevelSecurity**

   - RLSとドメインロジックの適切な分離
   - リポジトリ実装内でのRLS依存コードのカプセル化
   - 効率的なクエリパターンの確立
   - テスト環境でのRLSバイパス戦略

5. **エラーハンドリングの実装**
   - OpenAI API障害時の堅牢なリトライ戦略
   - 会話種別に応じたフォールバックメッセージ生成
   - コンテキスト長の段階的縮小アルゴリズム
   - ユーザーフレンドリーなエラー表示UI
   - エラーログとモニタリングの効果的な実装
   - エラー種別ごとのリカバリーフロー検証

## フィードバック収集方法

### レビュー方法

1. **コードレビュー**

   - 週次のコードレビューセッションを実施（毎週金曜日）
   - Pull Requestベースのレビュープロセス
   - アーキテクチャ準拠の観点からの検証
   - パフォーマンスと保守性の観点からの評価

2. **技術デモ**

   - 週次のデモセッションを実施（毎週水曜日）
   - 実装された機能の動作デモンストレーション
   - フィードバックシートによる定性的評価収集
   - ユーザーストーリーとの整合性検証

3. **アーキテクチャレビュー**
   - 2週間ごとのアーキテクチャレビューセッション
   - 実装されたアーキテクチャと設計ドキュメントの一致確認
   - 問題点と改善提案の収集
   - アーキテクチャの進化方向性の議論

### 評価指標

1. **定量的指標**

   - API応答時間測定（目標: 通常API 150ms以内、AI API 3秒以内）
   - コードカバレッジ（目標: 70%以上）
   - クライアントサイドパフォーマンス指標（FCP, TTI, CLS）
   - ビルド時間と依存関係サイズ

2. **定性的指標**

   - 開発者体験評価（アンケート形式）
   - アーキテクチャの理解度と適合性評価
   - 実装難易度と学習曲線の評価
   - コード可読性と保守性の評価

3. **技術的負債指標**
   - コード重複率の測定
   - レイヤー間依存関係違反の検出
   - TODOコメントとフィックスミー数の追跡
   - 型安全性違反の検出

## ユーザーテスト計画

プロトタイプの完成後、以下のユーザーテストを実施します：

1. **内部テスト**

   - 開発チームによる社内テスト（Week 4 Day 1-2）
   - 主要ユースケースの確認と基本機能の検証
   - クロスブラウザ・デバイス検証（基本的なレスポンシブ対応のみ）
   - エラーケースのシミュレーションと回復フロー確認

2. **限定ユーザーテスト**

   - 3-5名の協力ユーザーによるハンズオンテスト（Week 4 Day 3-4）
   - 事前に定義したタスクシナリオに基づく操作
   - Think Aloud方式によるフィードバック収集
   - ビジネスプラン作成の簡易シミュレーション

3. **フィードバックの集約と分析**

   - ユーザビリティ課題の特定と優先度付け
   - 本実装に向けた改善事項のリスト化
   - UI/UX改善提案の作成
   - AI対話品質向上のためのプロンプト調整提案

4. **ステークホルダーレビュー**
   - プロジェクト責任者と主要ステークホルダーへのデモンストレーション
   - プロトタイプ成果の発表と今後の方針議論
   - リスク評価と対策の合意形成
   - 本実装フェーズの優先事項とスコープ確定

ユーザーテストで得られた知見は、「本実装への反映」セクションで定義された各項目に統合されます。

## 結果と次のステップ

### 検証結果

_※PoCの完了後に記入_

### 本実装への反映

1. **アーキテクチャの確定**

   - PoCで検証されたアーキテクチャパターンを文書化
   - 成功したパターンと避けるべきパターンの明確化
   - アーキテクチャ決定記録（ADR）への反映

2. **実装ガイドラインの更新**

   - PoCから学んだベストプラクティスを反映
   - コード構造とファイル配置の標準化
   - 命名規則とコーディング規約の更新

3. **開発プロセスの最適化**

   - PoCから得られた開発効率に関する知見の反映
   - より効率的なレビュープロセスの確立
   - 自動テストの効果的な実装戦略

4. **技術選定の最終確認**
   - 選定した技術スタックの適合性の確認
   - 問題があった技術の代替手段の検討
   - 追加すべき技術やツールの特定

### アーキテクチャ調整

1. **レイヤー構造の最適化**

   - PoCの結果に基づくレイヤー間の責任分担の調整
   - 過度な抽象化の排除または強化
   - ボイラープレートコードの削減戦略

2. **パフォーマンス対策**

   - パフォーマンスボトルネックへの対応計画
   - SSRとCSRの最適なバランスの決定
   - キャッシュ戦略の確立

3. **スケーラビリティ計画**

   - アーキテクチャのスケーラビリティ向上策
   - マイクロサービス化検討ポイントの特定
   - 将来的な拡張性を考慮した調整

4. **セキュリティ強化**
   - PoCで特定されたセキュリティリスクへの対応
   - 認証・認可システムの強化
   - データアクセス制御の最適化

### プロトタイプで実装するAI対話コンポーネント

プロトタイプでは以下のコンポーネントを実装し、AI対話システムの技術検証を行います。各コンポーネントの詳細な実装パターンは04_implementation_rules.mdを参照してください。

1. **PromptTemplateManager**: プロンプトテンプレートの管理と動的なレンダリングを担当
2. **ContextBuilder**: 対話コンテキストの構築と最適化を担当
3. **ConversationManager**: 会話セッションと履歴の管理を担当
4. **AIService**: OpenAI APIとの通信とエラーハンドリングを担当
5. **ContextBuildStrategy**: 会話種別に応じたコンテキスト構築戦略の実装

これらのコンポーネントの統合と実装パターンを検証することで、本実装におけるAI対話メッセージ構成の最適なアプローチを決定します。特に異なる会話種別がユーザー体験と対話効率にどのように影響するかを重点的に検証します。

> **注**: 各コンポーネントの詳細な実装例は[code_examples/03_prototype_development_examples.md](./code_examples/03_prototype_development_examples.md)を参照してください。

## 本実装への移行計画

プロトタイプから本実装への移行は以下の手順で実施します：

1. **コード資産の評価**

   - 再利用可能コードの特定と品質評価
   - リファクタリングが必要な部分の特定
   - 破棄すべきコードの決定
   - 主要コンポーネントの単体テスト整備状況の確認

2. **移行戦略**

   - コアコンポーネント（PromptTemplateManager、ContextBuilder等）の段階的移行
   - 必要に応じたリアーキテクティング（特にレイヤー間依存関係の見直し）
   - テストケースの移行と拡張
   - AIサービスとドメインロジックの分離度の再評価

3. **開発環境の統合**

   - プロトタイプ環境から本開発環境への設定移行
   - CI/CD設定の確立（GitHub ActionsとVercel連携）
   - テストデータの移行計画
   - 環境変数とシークレット管理の標準化

4. **リソース再配置計画**

   - プロトタイプ開発に従事したチームメンバーの本実装フェーズでの役割定義
   - 知識移転セッションの計画（必要に応じて）
   - 相互レビュー体制の確立
   - ドキュメント更新責任の明確化

5. **スケジュール調整**
   - プロトタイプの結果に基づくスケジュールの見直し
   - リスクの高い機能の優先実装計画の調整
   - 段階的リリース計画の詳細化
   - マイルストーンとチェックポイントの再設定

この移行計画は、プロトタイプ完了後の振り返りセッションで見直され、プロジェクトマネージャーと開発チームリーダーによって最終決定されます。

## アーキテクチャドキュメント更新プロセス

プロトタイプ開発の成果は、以下のステップでアーキテクチャドキュメントに反映します：

1. **検証結果のドキュメント化**

   - 各検証項目の成功/失敗評価
   - 直面した課題と解決策の記録
   - コンセプト実証の定量的/定性的な結果

2. **アーキテクチャフィードバック**

   - アーキテクチャ設計（02_architecture_design.md）の更新点の特定
   - 修正が必要なアーキテクチャ決定の一覧化
   - 追加すべき詳細設計やパターンの提案

3. **実装ルールへの反映**

   - 実装ルール（04_implementation_rules.md）への追加・修正事項の整理
   - ベストプラクティスと避けるべきパターンの文書化
   - コード例とサンプル実装の準備

4. **アーキテクチャ決定記録（ADR）の作成**
   - プロトタイプから得られた主要な知見をADRとして文書化
   - 決定理由と代替案の比較を含める
   - 将来のアーキテクチャ判断の参照資料として保存

このプロセスは、プロトタイプ完了から1週間以内に実施し、アーキテクチャドキュメントの更新は本実装開始前に完了させます。

## リポジトリとRLSの実装パターン検証

プロトタイプでは以下のポイントに焦点を当ててリポジトリパターンを検証します：

1. **RLSとアプリケーションロジックの分離**:

   - リポジトリインターフェースはドメイン層に配置し、RLSに依存しない設計
   - 実装クラスの命名規則は{Infrastructure}PascalCaseRepositoryの形式に統一（例：SupabaseUserRepository）
   - モック実装でのテスト容易性の確保

2. **認証コンテキストの伝播**:

   - Sessionオブジェクトを必要なメソッドに明示的に渡す設計
   - ユーザーコンテキストに基づくRLSフィルタリングの実現

3. **型安全性の確保**:

   - IDの型変換をマッパー内に隔離し、リポジトリ実装のロジックと分離
   - 値オブジェクトの適切なシリアライズ/デシリアライズ

4. **エラーハンドリング**:
   - RLS違反の適切な検出とエラー変換
   - データベースエラーの抽象化とドメインエラーへの変換

リポジトリの具体的な実装パターン例については[code_examples/03_prototype_development_examples.md](./code_examples/03_prototype_development_examples.md)を参照してください。

### 簡略化された認証とRLSの連携

プロトタイプでは認証機能を簡略化しますが、RLSの検証には認証情報が必要です。この整合性を確保するために：

1. **最小限の認証基盤**:

   - Auth.jsの基本セットアップのみを実装し、必要最小限のSessionオブジェクトを生成
   - テスト用に予め定義された複数のロールを持つアカウントを準備（admin、user、guest）

2. **認証コンテキストのモック**:

   - 開発環境では`BYPASS_AUTH=true`環境変数を使用して認証をバイパス可能に設計
   - 認証バイパス時は、リクエストヘッダーから仮想ユーザーIDを受け取る仕組み

3. **RLS対応リポジトリの実装**:
   具体的な実装例は[code_examples/03_prototype_development_examples.md](./code_examples/03_prototype_development_examples.md)を参照してください。

4. **リポジトリファクトリの実装**:
   - 認証情報を各リポジトリに適切に注入するファクトリパターンを使用
   - テスト環境でのモック置換とRLSバイパスを容易にする設計

この方法により、認証機能を簡略化しながらも、RLSとリポジトリパターンの検証を適切に実施することができます。

## 型定義と安全な変換の検証

プロトタイプでは、型安全性の確保、バリデーションの集中化、マッピング戦略、エラー型の標準化などの型定義と変換メカニズムの検証を行います。

型定義と変換関数の具体的な実装例やパターンについては[05_type_definitions.md](05_type_definitions.md)および[code_examples/03_prototype_development_examples.md](./code_examples/03_prototype_development_examples.md)を参照してください。

### 歴史的事例分析機能の対象

歴史的事例分析機能については、以下の機能を実装検証の対象とします。

1. **基本データベース構造**

   - 事例データのスキーマ設計と実装
   - ベクトル検索対応のインデックス実装
   - 基本的なCRUD操作のAPI実装

2. **分析エンジン基盤**

   - 事例の類似性算出アルゴリズム
   - リスク評価の基本ロジック
   - 改善提案生成の基本フロー

3. **簡易UI**
   - 分析結果の可視化コンポーネント
   - リスク表示のヒートマップ
   - 類似事例一覧表示

#### プロトタイプとフル実装間のデータボリューム戦略

プロトタイプからフル実装への事例データ拡充は、以下の段階的アプローチで実現します。

1. **プロトタイプ段階（Phase 1）**

   - データ量: 50-100件の高品質事例データ
   - データ収集: 公開情報から手動キュレーション
   - カバレッジ: 主要業界（IT、小売、製造）の代表的事例
   - 目的: 機能検証とアルゴリズム調整

2. **初期拡張段階（Phase 2）**

   - データ量: 500-1,000件
   - データ取得手段: 半自動収集と手動レビュー
   - カバレッジ: より多様な業界と事例パターン
   - 目的: アルゴリズムの堅牢性向上とドメイン拡大

3. **スケーリング段階（Phase 3）**

   - データ量: 5,000-10,000件
   - データ取得手段: 自動収集パイプラインと品質チェック
   - カバレッジ: 主要業界の網羅的事例収集
   - 目的: 統計的信頼性の確保と精度向上

4. **フル実装段階（Phase 4）**
   - データ量: 50,000件以上
   - データ取得手段: 継続的収集システムと機械学習による品質向上
   - カバレッジ: 包括的な業界・規模・地域カバレッジ
   - 目的: 高度な分析と予測の実現

#### データ品質担保戦略

各フェーズでのデータ品質向上のために以下の取り組みを実施します：

1. **品質メトリクス定義**

   - データ完全性スコア（必須フィールドの充足度）
   - 情報の具体性スコア
   - ソース信頼性ランク
   - 時間的関連性（古い事例の現代との関連性評価）

2. **段階的な品質向上プロセス**

   - Phase 1: 全データの手動レビューと検証
   - Phase 2: サンプリングレビューと自動チェック
   - Phase 3: 機械学習による異常検出と品質予測
   - Phase 4: ユーザーフィードバックの統合とデータ改善サイクル

3. **データ拡充の優先順位付け**
   - 利用頻度の高い業界・分野の優先的拡充
   - ユーザー要求に基づく特定分野の強化
   - 時間的新鮮さに基づく更新優先度設定
   - データ分布の均一性確保

この段階的アプローチにより、プロトタイプでの機能検証を効率的に行いながら、フル実装への移行時には十分なデータ量と品質を確保することが可能になります。

### プロトタイプ対象機能と検証内容

#### 歴史的事例分析システム

**プロトタイプ範囲**:

- 基本的な事例データベース設計と実装
- pgvectorを使用した事例の類似性検索
- 基本的なリスク評価アルゴリズムの実装
- AIを活用した改善提案生成機能

**検証項目**:

- 50〜100件の事例データを使用した類似検索の精度検証
  - _注: 本番環境では01_requirements_definitionに定義された通り最低500事例が必要_
- pgvectorのインデックス最適化とクエリパフォーマンス
- 事例データ間の類似性計算方法の有効性
- AI活用による改善提案の質と多様性

**実装ポイント**:

- 事例データのモデル設計（分類体系、属性、メタデータ）
- 事例データの埋め込み生成プロセス
- 類似性検索のパフォーマンス最適化
- リスク要因の抽出と重み付け手法
- 改善提案生成プロンプトのテンプレート設計

**検証成功基準**:

- ビジネスプラン入力から10秒以内に類似事例の検索完了
- 類似事例の適合率70%以上
- リスク評価の一貫性（同様の事例に対する評価結果の標準偏差10%以内）
- AIによる改善提案が専門家評価で「有用」と判断される率60%以上
