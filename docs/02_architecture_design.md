# アーキテクチャ設計

最終更新日: 2025-03-26

## 本ドキュメントの目的

このドキュメントは「01_requirements_definition.md」で定義された技術要件・機能要件を実現するためのアーキテクチャ設計を詳細に記述しています。関連ドキュメントの目的と役割の違いは以下のとおりです：

- **01_requirements_definition.md**：「何を」実現するのか（What）
  - ビジネス・機能要件の定義
  - 非機能要件の定義
  - 技術スタックの概要
  - プロジェクト管理方法の概要

- **02_architecture_design.md**：「どのように」実現するのか（How）
  - アーキテクチャスタイルの選定と理由
  - ディレクトリ構造と各レイヤーの責務
  - 技術スタックの詳細な実装方法
  - モジュール分割と依存関係の設計
  - ドメインモデルの設計
  - 認証・認可の実装アーキテクチャ
  - エラー処理戦略の詳細

- **03_prototype_development.md**：プロトタイプでの検証事項（Verify）
  - プロトタイプの目的と検証内容
  - 検証する技術項目と評価方法
  - プロトタイプの実装範囲と制限

- **04_implementation_rules.md**：「どのように書くか」（Write）
  - 具体的なコーディング規約と命名規則
  - 実装パターン集と具体的なコード例
  - 型定義と安全な変換関数の実装詳細
  - リポジトリパターンとRLSの実装詳細

01で定義された要件に対して、02ではその具体的な実装方法とアーキテクチャ上の決定事項を詳細に記述しています。開発者は01で「何を作るべきか」を理解し、02で「どのように作るべきか」の指針を得ることができます。具体的な実装パターンやコード例については04を参照してください。

## アーキテクチャ概要

本プロジェクトでは、DDD風ヘキサゴナルアーキテクチャを採用します。これは、ドメイン駆動設計（DDD）の原則とヘキサゴナルアーキテクチャ（ポートとアダプター）を組み合わせたアプローチです。このアーキテクチャでは、ビジネスロジック（ドメイン）を中心に据え、外部依存性（UIやデータベース）との接続を明確に分離します。

ドメインを中心に置き、ビジネスロジックとインフラストラクチャを分離することで、テスト容易性、保守性、拡張性を向上させます。さらに、Next.jsのサーバーコンポーネントとクライアントコンポーネントの分離を活用して、適切な責務分割を実現します。

### DDD風ヘキサゴナルアーキテクチャの採用理由

1. **関心事の明確な分離**
   - ビジネスロジックとインフラストラクチャの分離
   - ドメインモデルの純粋性の維持
   - 依存関係の方向を内側（ドメイン）に向ける

2. **テスト容易性の向上**
   - ドメインロジックを独立してテスト可能
   - インフラストラクチャをモック/スタブ化しやすい
   - ユースケースの振る舞いを詳細に検証可能

3. **拡張性と保守性**
   - 新機能追加時の影響範囲を限定可能
   - 技術スタック変更時のドメインロジック保護
   - マイクロサービスへの将来的な移行も視野に入れた設計

### マイクロサービスへの進化パス

モノリシックアプリケーションとして開始しつつも、将来的なマイクロサービスへの移行を視野に入れた設計を採用します。以下にその戦略を示します：

1. **ドメイン境界の明確化**
   - ユーザー管理、プログラム管理、プロジェクト管理などの主要ドメインを明確に分離
   - 各ドメイン間の依存関係を最小限に抑制し、APIを介した連携を優先
   - 共有ドメインと特化ドメインを区別し、分割容易性を確保

2. **データ所有権の明確化**
   - 各ドメインが所有するデータとその責任範囲を明示
   - 共有データへのアクセスパターンを標準化
   - 最終的に分割する場合のデータ移行戦略を考慮したスキーマ設計

3. **段階的移行のロードマップ**
   - フェーズ1（現在）：モノリシックアプリケーションとしての実装
   - フェーズ2：内部モジュール化と境界の強化
   - フェーズ3：共有ライブラリとしての依存関係の抽出
   - フェーズ4：BFFパターン導入による段階的分離
   - フェーズ5：完全なマイクロサービス化（必要に応じて）

4. **チーム構造との整合**
   - 将来的なチーム拡大に合わせた責任範囲の設計
   - 「2ピザチーム」原則を考慮したサービス境界の設定
   - コンウェイの法則を活用したチームとアーキテクチャの共進化

この進化パスにより、ビジネスの成長に合わせて段階的にシステムを進化させることが可能になります。初期段階では開発効率を優先しつつも、将来的なスケーリングを見据えた設計判断を行います。

### プロトタイプ検証との連携

このアーキテクチャ設計は、プロトタイプ開発（03_prototype_development.md参照）での検証を通じて有効性を確認します。主な検証ポイントは以下の通りです：

1. **DDDパターンの実装検証**：エンティティとリポジトリの分離、ドメインロジックの独立性
2. **レイヤー分離の実効性**：ドメイン、アプリケーション、インフラの責務分離が適切か
3. **Next.js App Router環境での実装**：サーバーコンポーネントとの統合、データフロー
4. **AIサービス統合の効率性**：プロンプト管理、コンテキスト構築、エラーハンドリング
5. **RLSとドメインセキュリティの連携**：認証情報の適切な伝播、セキュリティの二重防御

プロトタイプからのフィードバックは、以下のプロセスでアーキテクチャ設計に反映します：

1. プロトタイプ完了後、検証結果の評価会議を実施
2. アーキテクチャ上の課題と成功点を文書化
3. 必要に応じて本ドキュメントを更新（ADRに記録）
4. 実装ルール（04_implementation_rules.md）への反映

この検証サイクルにより、実践に基づいたアーキテクチャの改良を継続的に行います。

### 国際化（i18n）アーキテクチャ

本プロジェクトでは、多言語対応と国際化を効率的に実現するため、以下のアーキテクチャを採用します。

1. **リソースバンドルベースの国際化**
   - 言語リソースを階層的に組織化（共通リソース、機能固有リソース）
   - JSON形式による言語リソース管理
   - フォールバック機構によるリソース欠損時の対応
   
2. **i18n管理モジュール**
   - 集中管理型の言語リソース読み込みメカニズム
   - Reactコンテキストを使用した言語状態の提供
   - フォーマット関数とプレースホルダー処理のユーティリティ
   - 言語検出と自動切り替え機能
   
3. **言語リソースの最適化**
   - 言語別のコード分割とレイジーローディング
   - リソースバンドルのキャッシュ戦略
   - エッジキャッシュを活用した配信最適化
   - リソース更新時のキャッシュ無効化メカニズム
   
4. **インターフェースの国際化対応**
   - Reactカスタムフックによる翻訳関数の提供（useTranslation）
   - 言語切り替えコンポーネントの共通実装
   - RTL対応のレイアウト切り替え機構
   - 言語固有のスタイル調整機能

5. **バックエンドの国際化対応**
   - API応答の多言語対応
   - エラーメッセージの多言語化
   - 日付、数値、通貨のフォーマット処理
   - 言語依存ロジックの抽象化

6. **RTL（右から左への記述）言語サポート**
   - RTL対応レイアウトの自動切り替え
     - `dir="rtl"` 属性の動的適用
     - TailwindCSSの `rtl:` バリアント活用
     - Flex方向と余白の自動調整
   - 双方向テキスト処理
     - Unicode双方向アルゴリズムの適切な実装
     - テキスト整列の言語依存調整
   - RTL特有のUIコンポーネント調整
     - アイコン・矢印の向き反転
     - スクロールバーの位置調整
     - スライダー・カルーセルの動作反転
   - RTLテスト自動化
     - RTLモード専用のビジュアルリグレッションテスト
     - 双方向テキスト表示の検証

7. **言語特化プロンプト戦略**
   - 言語ごとのプロンプトテンプレート最適化
   - 文化的文脈の調整メカニズム
   - 言語モデルパラメータの言語別最適化（温度、最大トークン等）
   - 多言語データセットを活用した評価とフィードバック

国際化アーキテクチャは、次の技術スタックに基づいて実装されます：

- Next.js App Routerの国際化機能
- next-intl（メッセージカタログ、フォーマッティング）
- ICU MessageFormat（複数形、性別対応など複雑な翻訳パターン）
- Tailwind CSSによるRTL対応（rtl: バリアントを活用）
- Format.jsのIntl APIラッパー（日付、数値、相対時間など）

この国際化アーキテクチャにより、ユーザーに一貫した多言語体験を提供しつつ、開発効率と保守性を確保します。

### 歴史的事例分析システムアーキテクチャ

ビジネスプランのリスク評価と改善提案を行うための歴史的事例分析システムは、以下のアーキテクチャコンポーネントで構成されます。

1. **事例データベース**
   - 成功・失敗事例の構造化データストレージ
   - 事例のベクトル表現とセマンティック検索
   - メタデータによる分類と索引付け
   - 時系列データの効率的な保存と検索
   
2. **分析エンジン**
   - パターンマッチングアルゴリズム
   - 機械学習ベースの分類モデル
   - 類似度計算とクラスタリング機能
   - 時系列分析と予測モデル
   - ルールベースの評価システム
   
3. **コンテキスト適応機構**
   - ユーザープロジェクトの特性抽出
   - 業界・セクター固有の評価ルール適用
   - 状況に応じた分析パラメータ調整
   - 段階的な詳細度制御
   
4. **レポーティングシステム**
   - リスク視覚化コンポーネント
   - 対話型の分析結果探索インターフェース
   - エビデンスベースの改善提案生成
   - カスタマイズ可能なレポートテンプレート

5. **AIアシスト統合**
   - GPTモデルによる改善提案の自然言語生成
   - ユーザー質問に対する説明生成
   - 分析結果解釈の支援
   - 提案のパーソナライズと具体化

## 型定義戦略

AiStartでは型安全性を最優先し、各レイヤーに適切な型定義を配置して、重複を避けつつ責務の明確な分離を実現します。型定義の基本方針や詳細な実装方法については、[05_type_definitions.md](05_type_definitions.md)を参照してください。

### 型階層の概要

本アーキテクチャでは以下の型階層構造を採用しています：

- **ドメイン層**: 値オブジェクト、エンティティなどの純粋なドメインモデル型
- **アプリケーション層**: DTOおよびアプリケーション固有型
- **インフラストラクチャ層**: DBスキーマ型
- **プレゼンテーション層**: UI状態型、API入出力型

詳細な型定義、命名規則、型変換パターン、共通型については[05_type_definitions.md](05_type_definitions.md)に集約されています。

### 推奨ディレクトリ構造

ゼロから最適化したディレクトリ構造を以下のように提案します。この構造は、コンポーネントの再利用性、責務の分離、保守性の向上を目指して設計されています。

```
/
├── app/                      # Next.js App Router
│   ├── (auth)/               # 認証関連ルート (グループ)
│   ├── (dashboard)/          # ダッシュボード関連ルート (グループ)
│   ├── api/                  # API Routes
│   └── [...locale]/          # 国際化ルート
│
├── domain/                   # ドメイン層
│   ├── models/               # ドメインモデル
│   │   ├── entities/         # エンティティ
│   │   └── value-objects/    # 値オブジェクト
│   ├── services/             # ドメインサービス
│   ├── repositories/         # リポジトリインターフェース
│   └── events/               # ドメインイベント
│
├── application/              # アプリケーション層
│   ├── usecases/             # ユースケース
│   └── dtos/                 # データ転送オブジェクト
│
├── infrastructure/           # インフラストラクチャ層
│   ├── database/             # データベース関連
│   │   ├── schema/           # Drizzle Schema
│   │   ├── migrations/       # DBマイグレーション
│   │   └── repositories/     # リポジトリ実装
│   ├── ai/                   # AI関連
│   │   ├── providers/        # 各AIプロバイダーの実装
│   │   ├── adapters/         # AIアダプター
│   │   └── prompt-templates/ # プロンプトテンプレート
│   ├── mappers/              # データマッパー
│   ├── auth/                 # 認証・認可
│   └── external-services/    # 外部サービス連携
│
├── presentation/             # プレゼンテーション層
│   ├── components/           # Reactコンポーネント
│   │   ├── common/           # 共通コンポーネント
│   │   ├── layouts/          # レイアウトコンポーネント
│   │   ├── forms/            # フォームコンポーネント
│   │   └── feature-specific/ # 機能固有コンポーネント
│   ├── hooks/                # Reactフック
│   ├── providers/            # コンテキストプロバイダー
│   └── utils/                # プレゼンテーション層のユーティリティ
│
├── shared/                   # 共有リソース
│   ├── types/                # 共通型定義
│   ├── utils/                # 共通ユーティリティ関数
│   ├── constants/            # 定数
│   └── errors/               # エラー定義
│
├── config/                   # アプリケーション設定
│   ├── environment.ts        # 環境変数処理
│   ├── feature-flags.ts      # 機能フラグ
│   └── app-config.ts         # アプリ設定
│
├── i18n/                     # 国際化リソース
│   ├── locales/              # 言語リソース
│   ├── config.ts             # i18n設定
│   └── types/                # i18n関連型定義
│
└── tests/                    # テスト
    ├── unit/                 # 単体テスト
    ├── integration/          # 統合テスト
    └── e2e/                  # E2Eテスト
```

この構造は以下の利点を持ちます：

1. **型定義の重複を回避**：型定義は各レイヤーの実装と一緒に配置
2. **関心の明確な分離**：各レイヤーとドメイン機能の責務を明確に定義
3. **保守性の向上**：関連するコードが近くに配置され、変更が容易
4. **スケーラビリティ**：機能追加が容易で、機能別の整理が一貫
5. **Next.jsとの統合**：Next.jsのApp Routerと自然に統合

## 技術スタック選定

### フロントエンド

**フレームワーク: Next.js (React 18+)**
- App Routerアーキテクチャによるファイルベースルーティング
- サーバーコンポーネントとクライアントコンポーネントの適切な使い分け
- 静的生成（Static Generation）と動的レンダリングの選択的適用

**UI構築: Tailwind CSS + shadcn/ui**
- ユーティリティファーストCSSフレームワークによる効率的なUI実装
- コンポーネントライブラリとしてshadcn/uiを活用（カスタマイズ性重視）
- アイコンライブラリとしてlucide-reactを統一使用

**状態管理: React Context API + TanStack Query**
- グローバル状態はReact Context APIで管理（必要最小限に抑制）
- サーバーデータはTanStack Query（旧React Query）で管理
- キャッシュ戦略を統一し、不要な再取得を防止

**フォント管理:**
- 英語コンテンツ: Hanken Grotesk
- 日本語コンテンツ: Noto Sans JP
- Next.jsの組み込みフォント最適化を活用

### バックエンド

**サーバーランタイム: Node.js v22 LTS (Jod)**
- TypeScriptによる型安全な実装
- モジュール分割と責務の明確化によるメンテナンス性向上

**依存性注入 (DI): tsyringe**
- 宣言的なDIによるコンポーネント結合度の低減
- `@injectable`デコレータを活用したクラス自動登録
- インターフェースと実装の明確な分離
- テスト容易性の向上とモック置換の簡素化

**API実装: Next.js API Routes + Edge Runtime**
- RESTfulなエンドポイント設計
- Route Handlersによる効率的なAPI実装
- 認証・認可はミドルウェアで一元管理

**データベース: PostgreSQL (via Supabase)**
- リレーショナルデータモデルの活用
- pgvector拡張によるベクトル検索機能
- Row Level Security (RLS)による行レベルのアクセス制御

**ORM: Drizzle ORM**
- 型安全なクエリビルダー
- マイグレーション管理（Drizzle Kit）
- 低オーバーヘッドで高パフォーマンス

**認証: Auth.js**
- OAuth2+OIDCベースの認証（Auth.js）
- 主要プロバイダー: Google, GitHub, Microsoft
- セッション管理: セキュアなJWT（HttpOnly Cookie）

### AI統合

**マルチモデルアーキテクチャ**
- マルチプロバイダー対応の抽象化レイヤー
- モデル切替機能によるAIプロバイダー間の透過的な切り替え
- コンテキスト依存のAIモデル選択ロジック

**対応AIプロバイダー**
- **OpenAI**: GPT-4o、GPT-3.5、GPT-o3-mini（小規模で効率的）
- **Anthropic**: Claude-3.7-sonnet（文脈理解に優れたモデル）
- **Google**: Gemini-2.5-pro（マルチモーダル対応）
- **その他オープンソースモデル**: Ollama経由でのローカルモデル実行（プライバシー重視）

**AIオーケストレーション**
- モデル選択戦略（コスト、性能、速度の最適化）
- フォールバックメカニズム（モデル障害時の代替手段）
- リクエスト分配と負荷分散
- 使用量モニタリングとコスト最適化

**ベクトルデータベース: PostgreSQL + pgvector**
- 埋め込みベクトルの効率的な保存と検索
- 類似度検索によるコンテキスト検索の最適化
- 複数埋め込みモデル対応（OpenAI、Cohere、Sentence Transformers等）

### 開発環境

**コードエディタ: Cursor**
- AIアシスト機能を活用した効率的な開発
- TypeScript型チェックと統合された開発体験
- コードコンテキスト理解に基づく補完機能

**バージョン管理: GitHub**
- プルリクエストベースの協業
- コードレビュー・イシュー管理の一元化
- GitHub Actionsによる自動化

**CI/CD: GitHub Actions + Vercel**
- コード品質チェック自動化（ESLint, TypeScript型チェック）
- テスト自動実行（Jest, Cypress）
- Vercelへの自動デプロイ連携

**依存関係管理**
- package.json：Node.js依存パッケージの明示的な管理
- npm（または yarn、pnpm）：パッケージ依存関係の一貫した解決
- 依存バージョン指定方針：
  - 主要フレームワーク（Next.js、React）：メジャーバージョン固定（^14.0.0、^18.0.0）
  - 重要ライブラリ：マイナーバージョン固定（~4.5.0）
  - 開発ツール：最新版自動更新（latest）
- package-lock.json（または yarn.lock、pnpm-lock.yaml）によるロックファイル管理

### 国際化（i18n）技術

**ライブラリ: next-intl**
- Next.js向けの最適化された国際化ライブラリ
- App Routerとの統合による効率的なルーティング
- メッセージの型安全な取り扱い
- フォールバックロケール機能とリソース集約

**言語リソース管理:**
- JSON形式による階層的リソース構造
- 言語別のコード分割とオンデマンドローディング
- 型安全な翻訳キーアクセス（TypeScript型の自動生成）
- 翻訳管理ツールとの統合（内製または外部サービス）

**フォーマット機能:**
- ICU MessageFormat対応のプレースホルダー処理
- 日付、数値、通貨などのロケールに応じたフォーマッタ
- 単位や複数形の言語固有ルールの適用
- 方向性（LTR/RTL）の自動切り替え

**パフォーマンス最適化:**
- 言語リソースの動的インポートとコード分割
- サーバーコンポーネントでの翻訳処理最適化
- クライアントサイドのキャッシュ戦略
- 優先言語の高速検出と適用

### 歴史的事例分析技術

**データ管理:**
- **ベクトルストア:** pgvector（PostgreSQL拡張）
- **データ構造化:** Zod/TypeScript型による一貫した事例構造
- **分類システム:** 階層的タグ付けとメタデータ
- **データソース:** バッチインポート機能とAPI連携

**分析エンジン:**
- **類似性検索:** コサイン類似度による事例マッチング
- **分類モデル:** アンサンブル決定木（ランダムフォレスト）
- **パターン抽出:** 教師あり学習モデルとルールベースハイブリッド
- **予測モデル:** 時系列分析と回帰モデル
- **NLP処理:** 埋め込みベクトルによるセマンティック解析

**視覚化コンポーネント:**
- **グラフAPI:** Recharts/D3.js
- **リスクヒートマップ:** カスタムビジュアライゼーション
- **インタラクティブダッシュボード:** React Gridレイアウト
- **レポートエクスポート:** PDF/CSVエクスポート機能

**AI統合:**
- **コンテキスト生成:** 歴史的事例データからのAIプロンプト強化
- **説明生成:** 選択されたAIモデルによる対話式の分析結果説明
- **改善提案:** ルールベースとAI生成の組み合わせ
- **参照システム:** 歴史的事例へのエビデンスリンク

## モジュール分割・依存関係

### ドメイン層（Domain Layer）

ビジネスロジックの中心となる層です。外部依存を持たず、純粋なドメインロジックのみを含みます。

**主な構成要素**
- `domain/models/`: 値オブジェクトとエンティティ
  - `value-objects/`: 識別子を持たない値オブジェクト
  - `entities/`: 識別子を持つエンティティ
- `domain/services/`: ドメインサービス
- `domain/events/`: ドメインイベント
- `domain/repositories/`: リポジトリインターフェース（ポート）

**役割と責務**
- ビジネスルールとロジックを定義
- 他の層からの独立性を保ち、外部依存を持たない
- リポジトリインターフェースを通じて永続化の抽象化を提供

### アプリケーション層（Application Layer）

ユースケースを実装し、ドメイン層とインフラストラクチャ層を橋渡しします。

**主な構成要素**
- `application/usecases/`: ユースケース実装（機能別にサブディレクトリ化）
- `application/dtos/`: データ転送オブジェクト

**役割と責務**
- ユーザーの意図（ユースケース）を実装
- ドメインオブジェクトを操作してビジネスロジックを実行
- トランザクション制御やセキュリティチェックを担当
- 入出力データの変換（DTOの使用）

### インフラストラクチャ層（Infrastructure Layer）

外部サービスとの連携やデータの永続化を担当します。

**主な構成要素**
- `infrastructure/database/`: データベース関連
  - `schema/`: DB定義（Drizzle Schema）
  - `repositories/`: リポジトリ実装（ドメイン層のインターフェースを実装）
- `infrastructure/mappers/`: データ変換ロジック（機能別に整理）
- `infrastructure/auth/`: 認証・認可実装
- `infrastructure/ai/`: AI統合実装

**役割と責務**
- ドメイン層で定義されたリポジトリインターフェースの実装を提供
- 外部サービス（DB、AI、認証等）との統合
- データの永続化と取得
- モデル間のマッピング（DB ⇔ ドメインモデル、ドメインモデル ⇔ DTO）

### プレゼンテーション層（Presentation Layer）

ユーザーインターフェースとAPIエンドポイントを提供します。

**主な構成要素**
- `presentation/api/`: API定義（機能別にサブディレクトリ化）
- `presentation/ui/`: Web UI
  - `components/`: UIコンポーネント（共通・機能別に整理）
  - `hooks/`: Reactフック
  - `contexts/`: Reactコンテキスト
  - `types/`: UI固有の型定義

**役割と責務**
- ユーザーインターフェースの提供（UI、API）
- ユーザー入力の処理と検証
- アプリケーション層のユースケース呼び出し
- レスポンスのフォーマットと表示

### Next.js App Router統合

Next.jsのApp Routerは、プレゼンテーション層の実際の実装として機能します。

**主な構成要素**
- `app/`: Next.jsのルーティング・ページ実装
  - グループ化されたルート（例: `(dashboard)/`）
  - API Routes（`app/api/`）
  - レイアウトとページコンポーネント

**役割と責務**
- ルーティング構造の定義
- ページレイアウトの構成
- サーバーコンポーネントとクライアントコンポーネントの組み合わせ
- プレゼンテーション層のUIとAPIの実装

**app/とpresentation/uiの関係**
- `app/`：Next.jsのファイルベースルーティングを使用したページとレイアウト
  - ページやレイアウト内で`presentation/ui/components`からコンポーネントをimport
  - ルーティング、ミドルウェア、レイアウト定義を担当
  - SSR、SSG、ISRなどのレンダリング戦略を定義
- `presentation/ui`：再利用可能なUIコンポーネントとロジック
  - ページの構成要素となるUIコンポーネントを提供
  - 純粋なUI関連のロジック（hooks、contexts）を管理
  - ページに依存しない形で実装し、複数ページから再利用可能

**実装パターン例**については、[コード例集](/docs/restructuring/code_examples/02_architecture_design_examples.md)を参照してください。

### 依存関係の方向性

依存関係は内側に向かうように設計します。

```
Presentation → Application → Domain ← Infrastructure
```

- ドメイン層は他のどの層にも依存しない
- アプリケーション層はドメイン層のみに依存
- インフラストラクチャ層はドメイン層のインターフェース（ポート）に依存
- プレゼンテーション層はアプリケーション層のユースケースに依存

### マッパーとリポジトリの違い

**リポジトリ（Repository）**
- **ドメイン層のリポジトリ**（`domain/repositories/`）
  - インターフェースのみを定義（実装なし）
  - ドメインオブジェクトの保存・取得・検索操作を定義
  - データソースの詳細を抽象化
  
- **インフラ層のリポジトリ**（`infrastructure/database/repositories/`）
  - ドメイン層で定義されたインターフェースの具体的な実装
  - PostgreSQLやその他のデータソースとの実際の接続・操作
  - マッパーを利用してデータ変換を行う

**マッパー（Mapper）**
- **インフラ層のマッパー**（`infrastructure/mappers/`）
  - 異なるデータ表現間の変換ロジックを提供
  - 変換の種類:
    1. DBスキーマ → ドメインモデル
    2. ドメインモデル → DB保存用データ
    3. ドメインモデル → DTO（API応答用）
  - リポジトリ内から呼び出され、データ変換のロジックを分離

## 共有リソースと設定の区分

アプリケーション内の共有リソースと設定を明確に区分し、それぞれの責任範囲を定義します。

## データフロー・インフラ構成

### データフローの概要

**基本的なデータフロー**

1. ユーザーリクエスト → Next.js App Router/API Routes
2. API Routes → ユースケース（アプリケーション層）
3. ユースケース → ドメインサービス/エンティティ（ドメイン層）
4. ドメインロジック → リポジトリ（インターフェース）
5. リポジトリ実装（インフラストラクチャ層） → PostgreSQL
6. 結果を逆方向に伝播 → ユーザー

**AI対話フロー**

1. ユーザー入力 → Next.js API Routes
2. プロンプト構築（アプリケーション層）
3. ドメインコンテキスト取得（リポジトリ）
4. AI対話実行（OpenAI API with GPT-o3-mini）
5. 結果処理と保存（ドメイン層 → リポジトリ）
6. レスポンス返却 → ユーザー

### インフラ構成

**開発環境**
- ローカル開発: Next.js dev + Supabase CLI
- テスト環境: Vercelプレビュー + Supabase開発プロジェクト

**本番環境**
- フロントエンド/API: Vercel（本番）
- データベース: Supabase PostgreSQL（本番）
- ストレージ: Vercel Blob Storage（主要）+ Supabase Storage（補助）
- キャッシュ: Upstash Redis
- CDN: Vercelエッジネットワーク

**CI/CD**
- GitHub連携: プッシュやPRごとの自動ビルド・デプロイ
- 自動テスト: GitHub Actions
- データベースマイグレーション: Drizzle Kit + GitHub Actions

### 国際化データフロー

国際化機能のデータフロー図を以下に示します：

```
[クライアント]           [サーバー]                    [ストレージ]
   |                        |                             |
   |-- 言語設定要求 ------>|                             |
   |                        |-- 言語設定保存 ----------->| ユーザー設定DB
   |                        |                             |
   |-- ページ要求 --------->|                             |
   |                        |-- 言語設定取得 ----------->| ユーザー設定DB
   |                        |<- 言語設定返却 ------------| 
   |                        |                             |
   |                        |-- 言語リソース取得 -------->| 言語リソースバンドル
   |                        |<- 言語リソース返却 ---------| 
   |                        |                             |
   |<- レンダリング済HTML --| (サーバーコンポーネント)    |
   |                        |                             |
   |-- 追加リソース要求 --->|                             |
   |                        |-- 言語リソース取得 -------->| 言語リソースバンドル
   |<- 追加リソース返却 ----|<- 言語リソース返却 ---------| 
   |                        |                             |
```

#### 歴史的事例分析データフロー

歴史的事例分析システムのデータフロー図を以下に示します：

```
[ビジネスプラン]       [分析エンジン]             [データストア]
      |                      |                        |
      |-- プラン送信 ------->|                        |
      |                      |-- 類似事例検索 ------->| 事例データベース
      |                      |<- 類似事例返却 --------| 
      |                      |                        |
      |                      |-- パターン抽出 ------->| 分析モデルDB
      |                      |<- パターン返却 --------| 
      |                      |                        |
      |                      |-- リスク評価計算       |
      |                      |-- 成功確率予測         |
      |                      |-- 改善提案生成 ------->| GPTサービス
      |                      |<- 生成提案返却 --------| 
      |                      |                        |
      |<- 分析レポート返却 --|                        |
      |                      |-- 分析結果保存 -------->| 分析履歴DB
      |                      |                        |
```

## セキュリティ設計

### 認証認可方式

**認証方式**
- OAuth2+OIDCベースの認証（Auth.js）
- 主要プロバイダー: Google, GitHub, Microsoft
- セッション管理: セキュアなJWT（HttpOnly Cookie）

**認可方式**
- ロールベースアクセス制御（RBAC）
  - 管理者（Admin）
  - 一般ユーザー（User）
  - プレミアムユーザー（Premium）
- リソースごとの所有権チェック
- PostgreSQL Row Level Security (RLS)との連携

### データ保護

**保存データ**
- 機密情報の暗号化（AES-256）
- 個人情報の最小限の収集と匿名化
- データベースレベルでのRow Level Security適用

**通信データ**
- TLS 1.3による全通信の暗号化
- 安全なAPIトークン管理（有効期限、更新戦略）

**バックアップとリカバリ**
- 定期的な自動バックアップ（日次/週次/月次）
- ポイントインタイムリカバリ（PITR）
- データ復旧手順の文書化と定期テスト

### 脆弱性対策

**実装レベル**
- 入力検証とサニタイゼーション（Zod）
- CSRF対策（SameSite Cookie）
- XSS対策（Reactのエスケープ機能、CSP）
- HTTPS強制（Strict-Transport-Security）

**運用レベル**
- 依存パッケージの脆弱性スキャン（npm audit）
- 定期的なセキュリティレビュー
- レスポンスヘッダー最適化（Helmet.js等）

## アーキテクチャ図

### システムアーキテクチャ概要

```
┌──────────────────────────┐     ┌─────────────────────────┐
│                          │     │                         │
│   クライアント (ブラウザ)    │     │     ドメインモデル      │
│                          │     │                         │
└───────────────┬──────────┘     │  ┌─────────────────┐    │
                │                   │  │   Conversation  │    │
                ▼                   │  │    (エンティティ)   │    │
┌──────────────────────────┐     │  └─────────────────┘    │
│                          │     │  ┌─────────────────┐    │
│    プレゼンテーション層     │     │  │     Message     │    │
│    (Next.js App Router)    │     │  │    (Value Object) │    │
│                          │     │  └─────────────────┘    │
└───────────────┬──────────┘     │  ┌─────────────────┐    │
                │                   │  │     Prompt      │    │
                ▼                   │  │    (エンティティ)   │    │
┌──────────────────────────┐     │  └─────────────────┘    │
│                          │     │                         │
│     アプリケーション層     │     └─────────────────────────┘
│     (ユースケース)        │
│                          │     ┌─────────────────────────┐
└───────────────┬──────────┘     │                         │
                │                   │     リポジトリ層        │
                ▼                   │                         │
┌──────────────────────────┐     │  ┌─────────────────┐    │
│                          │     │  │ConversationRepo │    │
│       ドメイン層          │     │  │                 │    │
│  (モデル・ビジネスロジック)  │     │  │                 │    │
│                          │     │  └─────────────────┘    │
└─────┬─────────────┬──────┘     │  │  PromptRepo     │    │
      │             │           │  │                 │    │
      │             │           │  └─────────────────┘    │
┌─────▼─────┐ ┌─────▼─────┐     │                         │
│           │ │           │     └─────────────────────────┘
│ 外部API連携 │ │リポジトリ  │
│ (GPT-o3-mini)│ │インターフェース│
│           │ │           │
└─────┬─────┘ └─────┬─────┘
      │             │
      │             │
┌─────▼─────┐ ┌─────▼─────┐
│           │ │           │
│ OpenAI API │ │インフラストラクチャ層│
│           │ │ (リポジトリ実装)  │
│           │ │           │
└───────────┘ └─────┬─────┘
                    │
                    ▼
          ┌──────────────────┐
          │                  │
          │  PostgreSQL      │
          │  (Supabase)      │
          │                  │
          └───────┬──────────┘
                  │
          ┌───────▼──────────┐
          │                  │
          │  ストレージサービス  │
          │  (Vercel Blob/   │
          │   Supabase Storage)│
          │                  │
          └──────────────────┘
```

## データマッピング例

データマッピングの具体例については、[コード例集](/docs/restructuring/code_examples/02_architecture_design_examples.md#データマッピング例)を参照してください。

## 機能要件とアーキテクチャの対応関係

AiStartの主要機能と実装アーキテクチャの対応関係を明確にします。これにより、各機能がどのレイヤーとコンポーネントで実装されるかを把握できます。

### 主要機能の実装マッピング

| 機能要件 | ドメイン層 | アプリケーション層 | インフラストラクチャ層 | プレゼンテーション層 |
|---------|----------|-----------------|-------------------|-----------------|
| **ユーザー認証・管理** | User, Role (entities) | UserUsecase, AuthUsecase | AuthRepository, UserRepository, AuthService | AuthUI, ProfileUI |
| **プログラム管理** | Program, Category (entities) | ProgramUsecase | ProgramRepository, CategoryRepository | ProgramListUI, ProgramDetailUI |
| **ステップ管理** | Step, StepCondition (entities) | StepUsecase, StepFlowUsecase | StepRepository, StepConditionRepository | StepEditorUI, StepFlowUI |
| **コンテンツ管理** | Content, Prompt, Video (entities) | ContentUsecase, MediaUsecase | ContentRepository, StorageService | ContentEditorUI, MediaUploadUI |
| **プロジェクト管理** | Project, ProjectStatus (entities) | ProjectUsecase | ProjectRepository | ProjectDashboardUI, ProjectEditorUI |
| **AI支援機能** | Conversation, AIContext (entities) | AIConversationUsecase | AIService, VectorRepository | ChatUI, AIAssistantUI |
| **サブスクリプション管理** | Subscription, Plan (entities) | SubscriptionUsecase, BillingUsecase | SubscriptionRepository, PaymentService | SubscriptionUI, BillingUI |
| **成果物管理** | Output, OutputVersion (entities) | OutputUsecase, ExportUsecase | OutputRepository, ExportService | OutputEditorUI, OutputViewerUI |
| **添付ファイル管理** | Attachment, AttachmentMetadata (entities) | AttachmentUsecase | AttachmentRepository, StorageService | AttachmentUploadUI, FileManagerUI |

### 機能実装フロー図

下記は、プログラム管理機能の実装フローを例として示しています：

```
【ユーザー】 ⟶ 【UI】            ⟶ 【API】                ⟶ 【ユースケース】         ⟶ 【ドメイン】           ⟶ 【リポジトリ】         ⟶ 【DB】
  |              |                   |                        |                         |                       |                      |
  |       components/program/   api/program/            application/usecases/    domain/models/entities/  infrastructure/database/  PostgreSQL
  |       ProgramList.tsx      program.route.ts        program/ProgramUsecase.ts program/Program.ts      repositories/ProgramRepo  (Supabase)
  |              |                   |                        |                         |                       |                      |
  |⟵ 応答 ⟵ components/program/ ⟵ api/program/          ⟵ DTO変換              ⟵ ドメインロジック処理    ⟵ マッパー変換          ⟵ クエリ結果
    (HTML)  ProgramDetail.tsx    GET /api/programs/:id   (ProgramDTO)            (Programエンティティ)    (DBレコード→エンティティ)
```

### レイヤー間のデータフロー

1. **ユーザーインタラクション**:
   - ユーザーがUIを操作（例：プログラム一覧表示ボタンをクリック）
   - Next.js App Routerによるルーティング処理

2. **APIリクエスト**:
   - プレゼンテーション層のUIコンポーネントがAPIを呼び出し
   - API Routeがリクエストを受け、バリデーション処理

3. **ユースケース実行**:
   - アプリケーション層のユースケースがビジネスロジックを調整
   - 必要に応じて複数のドメインサービスやリポジトリを組み合わせる

4. **ドメインロジック処理**:
   - ドメイン層のエンティティやサービスがビジネスロジックを実行
   - ドメインルールを適用し、結果を返却

5. **データアクセス**:
   - インフラストラクチャ層のリポジトリがデータ取得・保存を担当
   - マッパーを使用してDBレコードとドメインモデル間の変換

6. **レスポンス返却**:
   - データをDTOに変換し、APIレスポンスとして返却
   - UIコンポーネントが結果を受け取り、表示を更新

### 機能別ディレクトリ構造

機能ごとの詳細なディレクトリ構造例については、[コード例集](/docs/restructuring/code_examples/02_architecture_design_examples.md)を参照してください。

## AIサービス層の設計

AiStartにおけるAI対話機能は、ユーザーのビジネスプラン作成を支援する中核機能です。この機能を実現するためのアーキテクチャ設計を以下に示します。

### メッセージ構成アーキテクチャ

メッセージ構成コンポーネントの詳細やコード例については、[コード例集](/docs/restructuring/code_examples/02_architecture_design_examples.md#コンテキスト最適化)を参照してください。

### 会話種別に基づくコンテキスト構築とプロンプト選択

AiStartでは、ユーザーの目的に応じて最適な対話を提供するため、会話種別の概念を導入します。会話種別に基づいて異なるコンテキスト構築戦略とプロンプト選択ロジックを適用することで、より状況に適した対話体験を実現します。

#### 会話種別の定義

```typescript
// 会話種別を表す列挙型
enum ConversationType {
  INITIAL = 'initial',        // 開始時
  CONTINUOUS = 'continuous',  // 継続時
  CHECKPOINT = 'checkpoint',  // チェック時
  OUTPUT_CREATION = 'output_creation', // 成果物作成時
}
```

#### データモデルの拡張

会話種別に対応したデータモデルの拡張例については、[コード例集](/docs/restructuring/code_examples/02_architecture_design_examples.md#コンテキスト最適化)を参照してください。

#### コンテキスト構築の戦略パターン

会話種別ごとに異なるコンテキスト構築戦略を適用するための戦略パターン実装例については、[コード例集](/docs/restructuring/code_examples/02_architecture_design_examples.md#コンテキスト最適化)を参照してください。

### メッセージフロー設計

AIサービス層のメッセージフローは、会話種別を考慮して次のように拡張されています：

1. **ユーザー入力フェーズ**
   - ユーザーがUIからメッセージを入力
   - 会話種別の選択または自動判定
   - フロントエンドがメッセージと会話種別をAPI Routeに送信

2. **コンテキスト構築フェーズ**
   - 会話種別に応じた戦略を選択
   - 戦略に基づいてプロジェクト情報、ステップ情報、過去の成果物からコンテキストを構築
   - 会話種別に応じたトークン配分で最適化

3. **プロンプト選択フェーズ**
   - ステップタイプと会話種別の両方に基づいて適切なプロンプトテンプレートを選択
   - 選択されたテンプレートをコンテキスト情報で変数置換

4. **メッセージ履歴管理フェーズ**
   - 過去の対話履歴を取得
   - トークン制限を考慮して履歴をフィルタリング
   - 新しいユーザーメッセージを追加

5. **APIリクエスト構築フェーズ**
   - システムプロンプト、対話履歴、ユーザーメッセージを結合
   - トークン使用量を推定し必要に応じて最適化
   - OpenAI APIリクエストの構築

5. **レスポンス処理フェーズ**
   - ストリーミングレスポンスの受信と処理
   - UIへの段階的な表示
   - 完了したレスポンスの履歴への保存

### データモデル

AIサービス層のデータモデル例については、[コード例集](/docs/restructuring/code_examples/02_architecture_design_examples.md#コンテキスト最適化)を参照してください。

この設計により、AIとの対話に必要なコンテキスト情報（過去のステップ成果物、プロジェクト状態など）を効率的に管理し、ユーザーに一貫した対話体験を提供します。また、プロンプトテンプレートの管理とバージョニングにより、対話品質の継続的な改善と最適化が可能になります。

### エラーハンドリングアーキテクチャ

AIを活用したサービスでは、外部API依存による不確実性に対処するための堅牢なエラーハンドリング戦略が不可欠です。AiStartでは多層的なエラーハンドリングアーキテクチャを採用し、システムの回復力と可用性を確保します。

リトライ戦略やフォールバックメカニズムなどの詳細なコード例については、[コード例集](/docs/restructuring/code_examples/02_architecture_design_examples.md#リトライメカニズム)を参照してください。

この多層的なエラーハンドリングアーキテクチャにより、AIサービスの障害に対する回復力が大幅に向上し、ユーザー体験の一貫性が確保されます。リトライ戦略、適切なエラー分類、フォールバックメカニズム、そしてユーザーフレンドリーなエラー表示を組み合わせることで、外部依存性に起因する問題を効果的に軽減します。

## 環境変数定義とアプリケーション設定

アプリケーション設定の一貫性と型安全性を確保するため、環境変数を体系的に管理します。Zodを使用した型検証と変数定義により、実行時エラーを事前に検出し、安全な設定管理を実現します。

### 環境変数の分類と管理

環境変数は以下のように論理的に分類されます：

1. **アプリケーション基本設定**
   - 基本URL、環境名、デバッグモードなど

2. **データベース接続設定**
   - PostgreSQL接続情報、プール設定など

3. **認証関連設定**
   - Auth.js設定、シークレットキー、JWTトークン設定

4. **OAuth設定**
   - 各プロバイダー（Google, GitHub, MS）のクライアントIDとシークレット

5. **Supabase設定**
   - URL、API Key、サービスロールキーなど

6. **ストレージ設定**
   - Vercel Blob、Supabase Storageの設定

7. **AIサービス設定**
   - OpenAI API Key、モデル設定、トークン制限など

8. **メール送信設定**
   - SMTPサーバー、認証情報、送信者アドレスなど

### 環境変数定義と検証

環境変数の定義と検証の具体例については、[コード例集](/docs/restructuring/code_examples/02_architecture_design_examples.md#環境変数定義)を参照してください。

### 環境変数の使用パターン

1. **直接インポート**
```typescript
   import { env } from '@/config/env';
   
   function uploadFile() {
     // 型安全に環境変数を使用
     const storageUrl = env.STORAGE_URL;
  // ...
   }
   ```

2. **サービス設定での使用**
```typescript
   import { env } from '@/config/env';
   
   export const databaseConfig = {
     url: env.DATABASE_URL,
     maxConnections: env.DATABASE_POOL_MAX,
     ssl: env.NODE_ENV === 'production',
   };
   ```

### 環境ごとの設定管理

- **開発環境**: `.env.development.local`（バージョン管理外）
- **テスト環境**: `.env.test`（CI/CDパイプラインで使用）
- **本番環境**: VercelやSupabaseのシークレット管理画面で設定

## リトライメカニズムと回復戦略

外部依存サービス（OpenAI API、データベース、ストレージなど）との通信における一時的な障害に対処するための堅牢なリトライメカニズムを実装します。

### リトライ戦略の原則

1. **エラー分類と選択的リトライ**
   - 一時的なエラー（ネットワーク障害、サーバー過負荷）：リトライ対象
   - 永続的なエラー（認証エラー、無効なパラメータ）：即時失敗

2. **指数バックオフと揺らぎ**
   - リトライ間隔を徐々に増加（例：500ms → 1000ms → 2000ms）
   - 揺らぎを追加（±10%）してサンダーハードプロブレムを回避

3. **最大リトライ回数の制限**
   - リソースの種類に応じた適切な最大リトライ回数
   - 重要度の高い操作は回数を増加

4. **サーキットブレーカーパターン**
   - 一定数の連続失敗で一定時間サービス呼び出しを停止
   - システム全体の安定性を確保

### リトライメカニズム実装

リトライメカニズムの実装例については、[コード例集](/docs/restructuring/code_examples/02_architecture_design_examples.md#リトライメカニズム)を参照してください。

### データベース操作のリトライロジック

データベース操作に対するリトライ実装例については、[コード例集](/docs/restructuring/code_examples/02_architecture_design_examples.md#リトライメカニズム)を参照してください。

## モニタリングとログ管理

効果的なシステム監視とログ管理により、問題の早期発見とパフォーマンス最適化を実現します。

### ログレベルと種類

- **ERROR**: システムの動作を妨げる重大な問題
- **WARN**: 潜在的な問題や異常な動作
- **INFO**: 重要なシステムイベント（起動、シャットダウン、大きな状態変化）
- **DEBUG**: トラブルシューティングに役立つ詳細情報（開発環境のみ）
- **TRACE**: 非常に詳細な実行フロー情報（特定の問題調査時のみ）

### 構造化ログの実装

```typescript
// ログエントリの基本構造
interface LogEntry {
  timestamp: string;      // ISO8601形式のタイムスタンプ
  level: LogLevel;        // ログレベル（ERROR, WARN, INFO, DEBUG, TRACE）
  message: string;        // 人間可読なメッセージ
  context?: Record<string, any>; // 追加コンテキスト情報
  userId?: string;        // 関連するユーザーID（該当する場合）
  requestId?: string;     // リクエスト識別子（分散トレーシング用）
  component: string;      // ログを出力したコンポーネント
  stackTrace?: string;    // エラーの場合のスタックトレース
}
```

### モニタリング対象

1. **アプリケーションメトリクス**
   - リクエスト数、レスポンス時間、エラー率
   - ルートごとのパフォーマンス統計
   - メモリ使用量、CPU使用率、イベントループ遅延

2. **ユーザー体験メトリクス**
   - First Contentful Paint (FCP)
   - Largest Contentful Paint (LCP)
   - First Input Delay (FID)
   - Cumulative Layout Shift (CLS)
   - クライアントサイドエラー率

3. **ビジネスメトリクス**
   - アクティブユーザー数
   - 機能別使用統計
   - コンバージョン指標
   - AI生成リクエスト数と成功率

### ログ収集と分析基盤

- **開発環境**: コンソール + ローカルログファイル
- **本番環境**: Vercel Logs + カスタム統合（DatadogまたはNew Relic）
- **ログの保持期間**: 30日（運用データ）、90日（集計・分析データ）

## パフォーマンス最適化戦略

アプリケーションのパフォーマンスと応答性を確保するための包括的な最適化戦略を実装します。

### クライアントサイド最適化

1. **コンポーネント分割と遅延ロード**
   - ルートベースのコード分割
   - 重いコンポーネントの遅延ロード（React.lazy/Suspense）
   - 下位ルート優先のコンポーネント構造

2. **レンダリング最適化**
   - 効率的なステート管理（不要な再レンダリングの回避）
   - メモ化（React.memo, useMemo, useCallback）
   - ビルトインコンポーネントの最適化（shadcn/ui）

3. **アセット最適化**
   - 画像の最適化（next/image、サイズ適合、WebP/AVIF形式）
   - フォントの最適化（サブセット化、preload）
   - CSSの最適化（Tailwind JIT、未使用スタイルの削除）

### サーバーサイド最適化

1. **レンダリング戦略**
   - Static Site Generation (SSG): 変更頻度の低いページ
   - Incremental Static Regeneration (ISR): 準静的コンテンツ
   - Server-Side Rendering (SSR): 動的だが頻繁に変わらないデータ
   - Client-Side Rendering (CSR): 高度にパーソナライズされたコンテンツ

2. **キャッシュ戦略**
   - React Server Components (RSC) キャッシュ
   - データキャッシュ（Vercel KV）
   - API応答キャッシュ（SWR, React Query）
   - ブラウザキャッシュ（Cache-Control, ETag）

3. **データベースパフォーマンス**
   - クエリ最適化（インデックス、効率的な結合）
   - 接続プーリング
   - 必要なフィールドのみの取得
   - N+1問題の回避

### AIレスポンス最適化

1. **ストリーミングレスポンス**
   - Server-Sent Events (SSE) を使用したAIレスポンスのストリーミング
   - プログレッシブUI更新

2. **プロンプト最適化**
   - コンテキスト圧縮技術
   - 重要情報の優先順位付け
   - プロンプトテンプレートの継続的改善

3. **クライアントサイドキャッシング**
   - 類似クエリの結果キャッシュ
   - 部分的な応答のキャッシュと再利用

### バンドルサイズ最適化

```bash
# バンドル分析ツールの実行
npm run analyze-bundle

# 出力例（抜粋）
Page                                     Size     First Load JS
┌ ● /                                    5.2 kB        85.7 kB
├   /_app                                0 B            80.5 kB
├ ○ /404                                 194 B          80.7 kB
├ ○ /api/auth/[...nextauth]              0 B            80.5 kB
├ λ /api/ai/chat                         0 B            80.5 kB
└ λ /projects/[id]                       29.2 kB       110 kB
+ First Load JS shared by all            80.5 kB
  ├ chunks/framework-8883d1e9be70c3da.js 45.7 kB
  ├ chunks/main-f65e66e62fc5ca53.js      30.7 kB
  ├ chunks/pages/_app-b555d5e1eab47959.js 296 B
  └ chunks/webpack-69bfa6990bb9e155.js   769 B
```

### パフォーマンスメトリクス

1. **フロントエンド**
   - Core Web Vitals: LCP < 2.5s, FID < 100ms, CLS < 0.1
   - Time to Interactive (TTI) < 3.8s
   - Total Blocking Time (TBT) < 200ms

2. **バックエンド**
   - API応答時間: P95 < 500ms, P99 < 1000ms
   - DB操作時間: P95 < 200ms, P99 < 500ms
   - AI応答初速: TTFB < 300ms

## 継続的インテグレーションとデプロイ

アプリケーションの開発からデプロイまでの一貫したパイプラインを構築し、品質とスピードを両立させます。

### CI/CDパイプライン

1. **コード品質チェック**
   - ESLint: コーディング標準の遵守
   - TypeScript: 型チェック
   - Prettier: コードフォーマット
   - テスト: ユニットテスト、統合テスト
   - カバレッジレポート: テストカバレッジ分析

2. **ビルドプロセス**
   - 依存関係のインストール
   - アプリケーションビルド
   - 静的アセットの最適化

3. **デプロイワークフロー**
   - プレビュー環境: Pull Request毎
   - ステージング環境: main/masterブランチへのマージ後
   - 本番環境: タグリリース後

### データベースマイグレーション管理

Drizzle Kitを使用して、データベースのバージョン管理とマイグレーションを安全に実行します。

1. **マイグレーションフロー**
   - スキーマ定義更新（Drizzle Schema）
   - マイグレーションファイル生成 (`drizzle-kit generate`)
   - マイグレーションの実行 (`drizzle-orm migrate`)

2. **環境ごとのマイグレーション戦略**
   - 開発: 自動実行（アプリ起動時）
   - テスト: 環境再構築時
   - ステージング: CI/CDパイプラインの一部として
   - 本番: 手動承認後に実行

### 環境分離とフィーチャーフラグ

1. **環境管理**
   - 開発（Development）: ローカル開発用
   - テスト（Testing）: 自動テスト実行用
   - プレビュー（Preview）: PR検証用
   - ステージング（Staging）: リリース前確認用
   - 本番（Production）: エンドユーザー向け

2. **フィーチャーフラグ**
   - 環境変数ベースのフラグ制御
   - ユーザーロールベースのアクセス制御
   - 段階的ロールアウト機能

## まとめと移行戦略

本アーキテクチャ設計は、AiStartの長期的な成長と進化を支える基盤となります。各コンポーネントは独立して開発・テスト可能であり、将来的なマイクロサービスへの移行も視野に入れています。

### アーキテクチャの主要メリット

1. **高い保守性と拡張性**
   - 関心の分離による変更影響範囲の最小化
   - ドメイン中心設計による業務変化への適応
   - 明確なレイヤー構造による理解しやすさ

2. **テスト容易性の向上**
   - 純粋なドメインロジックの単体テスト
   - モックを使用したインフラ依存のテスト
   - エンドツーエンドテストによる総合検証

3. **段階的な進化の実現**
   - 初期はモノリシックで迅速に開発
   - 成長に合わせた段階的なマイクロサービス化
   - ドメイン境界に沿った分割容易性

### 次のステップ

1. **プロトタイプ開発**
   - 本アーキテクチャに基づく初期プロトタイプの開発
   - 主要フローの検証と改善
   - パフォーマンス特性の評価

2. **開発ガイドライン整備**
   - コーディング規約の詳細化
   - 実装パターンの標準化
   - ナレッジベースの構築

3. **チーム体制の整備**
   - 機能領域に応じたチーム構成
   - 共通基盤のガバナンス体制
   - トレーニングと知識共有

このアーキテクチャ設計を出発点として、実装フェーズでの学びを反映しながら継続的に進化させていきます。