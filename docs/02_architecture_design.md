# アーキテクチャ設計

最終更新日: 2025-04-04

## 本ドキュメントの目的

このドキュメントは「01_requirements_definition.md」で定義された技術要件・機能要件を実現するためのアーキテクチャ設計を詳細に記述しています。関連ドキュメントの目的と役割の違いは以下のとおりです：

- **01_requirements_definition.md**：「何を」実現するのか（What）
  - ビジネス・機能要件の定義
  - 非機能要件の定義
  - 技術スタックの概要
  - プロジェクト管理方法の概要

- **02_architecture_design.md**：「どのように」実現するのか（How）
  - アーキテクチャスタイルの選定と理由
  - ディレクトリ構造と各レイヤーの責務
  - 技術スタックの詳細な実装方法
  - モジュール分割と依存関係の設計
  - ドメインモデルの設計
  - 認証・認可の実装アーキテクチャ
  - エラー処理戦略の詳細

- **03_prototype_development.md**：プロトタイプでの検証事項（Verify）
  - プロトタイプの目的と検証内容
  - 検証する技術項目と評価方法
  - プロトタイプの実装範囲と制限

- **04_implementation_rules.md**：「どのように書くか」（Write）
  - 具体的なコーディング規約と命名規則
  - 実装パターン集と具体的なコード例
  - 型定義と安全な変換関数の実装詳細
  - リポジトリパターンとRLSの実装詳細
  - DIコンテナ (tsyringe) の利用方針
  - 状態管理戦略
  - エラーハンドリング規則
  - サーバーコンポーネントとクライアントコンポーネント間のデータ転送規則

01で定義された要件に対して、02ではその具体的な実装方法とアーキテクチャ上の決定事項を詳細に記述しています。開発者は01で「何を作るべきか」を理解し、02で「どのように作るべきか」の指針を得ることができます。具体的な実装ルールやコード例については04を参照してください。

## アーキテクチャ概要

本プロジェクトでは、DDD風ヘキサゴナルアーキテクチャを採用します。これは、ドメイン駆動設計（DDD）の原則とヘキサゴナルアーキテクチャ（ポートとアダプター）を組み合わせたアプローチです。このアーキテクチャでは、ビジネスロジック（ドメイン）を中心に据え、外部依存性（UIやデータベース）との接続を明確に分離します。

ドメインを中心に置き、ビジネスロジックとインフラストラクチャを分離することで、テスト容易性、保守性、拡張性を向上させます。さらに、Next.jsのサーバーコンポーネントとクライアントコンポーネントの分離を活用して、適切な責務分割を実現します。

### DDD風ヘキサゴナルアーキテクチャの採用理由

1. **関心事の明確な分離**
   - ビジネスロジックとインフラストラクチャの分離
   - ドメインモデルの純粋性の維持
   - 依存関係の方向を内側（ドメイン）に向ける

2. **テスト容易性の向上**
   - ドメインロジックを独立してテスト可能
   - インフラストラクチャをモック/スタブ化しやすい
   - ユースケースの振る舞いを詳細に検証可能

3. **拡張性と保守性**
   - 新機能追加時の影響範囲を限定可能
   - 技術スタック変更時のドメインロジック保護
   - マイクロサービスへの将来的な移行も視野に入れた設計

### マイクロサービスへの進化パス

モノリシックアプリケーションとして開始しつつも、将来的なマイクロサービスへの移行を視野に入れた設計を採用します。以下にその戦略を示します：

1. **ドメイン境界の明確化**
   - ユーザー管理、プログラム管理、プロジェクト管理などの主要ドメインを明確に分離
   - 各ドメイン間の依存関係を最小限に抑制し、APIを介した連携を優先
   - 共有ドメインと特化ドメインを区別し、分割容易性を確保

2. **データ所有権の明確化**
   - 各ドメインが所有するデータとその責任範囲を明示
   - 共有データへのアクセスパターンを標準化
   - 最終的に分割する場合のデータ移行戦略を考慮したスキーマ設計

3. **段階的移行のロードマップ**
   - フェーズ1（現在）：モノリシックアプリケーションとしての実装
   - フェーズ2：内部モジュール化と境界の強化
   - フェーズ3：共有ライブラリとしての依存関係の抽出
   - フェーズ4：BFFパターン導入による段階的分離
   - フェーズ5：完全なマイクロサービス化（必要に応じて）

4. **チーム構造との整合**
   - 将来的なチーム拡大に合わせた責任範囲の設計
   - 「2ピザチーム」原則を考慮したサービス境界の設定
   - コンウェイの法則を活用したチームとアーキテクチャの共進化

この進化パスにより、ビジネスの成長に合わせて段階的にシステムを進化させることが可能になります。初期段階では開発効率を優先しつつも、将来的なスケーリングを見据えた設計判断を行います。

### プロトタイプ検証との連携

このアーキテクチャ設計は、プロトタイプ開発（03_prototype_development.md参照）での検証を通じて有効性を確認します。主な検証ポイントは以下の通りです：

1. **DDDパターンの実装検証**：エンティティとリポジトリの分離、ドメインロジックの独立性
2. **レイヤー分離の実効性**：ドメイン、アプリケーション、インフラの責務分離が適切か
3. **Next.js App Router環境での実装**：サーバーコンポーネントとの統合、データフロー
4. **AIサービス統合の効率性**：プロンプト管理、コンテキスト構築、エラーハンドリング
5. **RLSとドメインセキュリティの連携**：認証情報の適切な伝播、セキュリティの二重防御

プロトタイプからのフィードバックは、以下のプロセスでアーキテクチャ設計に反映します：

1. プロトタイプ完了後、検証結果の評価会議を実施
2. アーキテクチャ上の課題と成功点を文書化 (ADR: Architecture Decision Record を活用)
3. 必要に応じて本ドキュメントを更新（ADRに記録）
4. 実装ルール（04_implementation_rules.md）への反映

この検証サイクルにより、実践に基づいたアーキテクチャの改良を継続的に行います。

### 国際化（i18n）アーキテクチャ

本プロジェクトでは、多言語対応と国際化を効率的に実現するため、以下のアーキテクチャを採用します。

1. **リソースバンドルベースの国際化**
   - 言語リソースを階層的に組織化（共通リソース、機能固有リソース）
   - JSON形式による言語リソース管理
   - フォールバック機構によるリソース欠損時の対応
   
2. **i18n管理モジュール**
   - 集中管理型の言語リソース読み込みメカニズム
   - Reactコンテキストを使用した言語状態の提供
   - フォーマット関数とプレースホルダー処理のユーティリティ
   - 言語検出と自動切り替え機能
   
3. **言語リソースの最適化**
   - 言語別のコード分割とレイジーローディング
   - リソースバンドルのキャッシュ戦略
   - エッジキャッシュを活用した配信最適化
   - リソース更新時のキャッシュ無効化メカニズム
   
4. **インターフェースの国際化対応**
   - Reactカスタムフックによる翻訳関数の提供（useTranslation）
   - 言語切り替えコンポーネントの共通実装
   - RTL対応のレイアウト切り替え機構
   - 言語固有のスタイル調整機能

5. **バックエンドの国際化対応**
   - API応答の多言語対応
   - エラーメッセージの多言語化
   - 日付、数値、通貨のフォーマット処理
   - 言語依存ロジックの抽象化

6. **RTL（右から左への記述）言語サポート**
   - RTL対応レイアウトの自動切り替え
     - `dir="rtl"` 属性の動的適用
     - TailwindCSSの `rtl:` バリアント活用
     - Flex方向と余白の自動調整
   - 双方向テキスト処理
     - Unicode双方向アルゴリズムの適切な実装
     - テキスト整列の言語依存調整
   - RTL特有のUIコンポーネント調整
     - アイコン・矢印の向き反転
     - スクロールバーの位置調整
     - スライダー・カルーセルの動作反転
   - RTLテスト自動化
     - RTLモード専用のビジュアルリグレッションテスト
     - 双方向テキスト表示の検証

7. **言語特化プロンプト戦略**
   - 言語ごとのプロンプトテンプレート最適化
   - 文化的文脈の調整メカニズム
   - 言語モデルパラメータの言語別最適化（温度、最大トークン等）
   - 多言語データセットを活用した評価とフィードバック

国際化アーキテクチャは、次の技術スタックに基づいて実装されます：

- Next.js App Routerの国際化機能
- next-intl（メッセージカタログ、フォーマッティング）
- ICU MessageFormat（複数形、性別対応など複雑な翻訳パターン）
- Tailwind CSSによるRTL対応（rtl: バリアントを活用）
- Format.jsのIntl APIラッパー（日付、数値、相対時間など）

この国際化アーキテクチャにより、ユーザーに一貫した多言語体験を提供しつつ、開発効率と保守性を確保します。

### チャット機能アーキテクチャ

ユーザーとAIの対話を効果的に管理するためのチャット機能は、以下のアーキテクチャコンポーネントで構成されます：

1. **メッセージモデルと状態管理**
   - **メッセージデータモデル**
     - role（system/user/assistant）による発信者区分
     - content（メッセージ内容）の適切な形式
     - プロジェクト・ステップとの関連付け
     - タイムスタンプと順序の管理
   - **メッセージ状態管理**
     - React状態とReact Queryによるデータフロー
     - 最適化されたローカル状態とサーバー状態の同期
     - リアルタイムな反映とバッチ処理の適切な使い分け
   - **会話種別の状態管理**
     - 対話フェーズ（開始/継続/チェック/成果物作成）の管理
     - フェーズ移行の条件と処理

2. **コンテキスト構築パイプライン**
   - **コンテキスト収集**
     - 過去の対話履歴の取得と加工
     - プロジェクト情報の統合
     - 前のステップの成果物の要約と統合
   - **コンテキスト最適化**
     - トークン制限に基づく履歴圧縮
     - 重要情報の優先保持アルゴリズム
     - 関連性に基づく情報フィルタリング
   - **動的コンテキスト調整**
     - 対話の方向性に基づくコンテキスト重み付け
     - 会話種別に応じたコンテキスト構成の変更

3. **UI/UXアーキテクチャ**
   - **レイアウトとコンポーネント構成**
     - メッセージリスト表示と自動スクロール
     - 入力フォームとコントロールパネル
     - 設定パネルとオプション制御
   - **ユーザーインタラクションフロー**
     - メッセージ送信・受信の状態遷移
     - エラー表示と回復フロー
     - 対話制御（送信、チェック、成果物作成、リセット）
   - **レスポンシブデザイン戦略**
     - デバイスサイズに応じたレイアウト調整
     - タッチインターフェース最適化
     - モバイルフレンドリーなインタラクション

4. **AIメッセージ生成パイプライン**
   - **プロンプト選択と構築**
     - 会話種別とステップ情報に基づく適切なプロンプト選択
     - ダイナミック変数の置換処理
     - システムプロンプトと対話履歴の結合
   - **API通信と非同期処理**
     - ストリーミングレスポンス処理
     - タイムアウト管理と自動再試行
     - バックオフ戦略による安定性確保
   - **エラーハンドリングとリカバリー**
     - エラー種別の分類と適切な対応
     - ユーザーフレンドリーなエラーメッセージ
     - 致命的でないエラーからの回復メカニズム

5. **永続化と同期戦略**
   - **メッセージ永続化**
     - トランザクション整合性の確保
     - 効率的なバルク保存処理
     - セッション維持と復元機能
   - **リアルタイム同期**
     - 複数デバイス間での同期メカニズム
     - 競合解決アルゴリズム
     - 部分的なオフライン対応

6. **パフォーマンス最適化**
   - **データロード最適化**
     - 遅延ロードと部分的なメッセージ取得
     - データプリフェッチ戦略
     - キャッシュ利用の最適化
   - **レンダリング最適化**
     - メッセージリストの仮想化スクロール
     - メモ化による再レンダリング抑制
     - Web Workerの活用による処理の分離

このアーキテクチャによりユーザーは安定性と応答性を備えたAI対話環境を利用でき、開発者はメンテナンス性の高いシステムを構築できます。

### ステップ管理アーキテクチャ

プログラム内の学習・作業ステップを効果的に管理・進行するためのステップ管理システムは、以下のアーキテクチャで構成されます：

1. **ステップデータモデルとリレーション**
   - **コアエンティティモデル**
     - StepDefinition（ステップの基本定義）
     - StepProgress（ユーザーごとの進捗状態）
     - StepOutput（成果物とその状態）
   - **リレーションシップモデル**
     - プログラムとステップの階層関係
     - ステップ間の依存関係グラフ
     - プロジェクトとステップ進捗の関連
   - **メタデータモデル**
     - ステップタイプと特性
     - 想定所要時間と難易度
     - ステップ間のフロー制御情報

2. **ステップ進行フローエンジン**
   - **条件評価システム**
     - 前提条件の検証ロジック
     - 完了条件の複合評価
     - 条件分岐の解決アルゴリズム
   - **状態遷移管理**
     - 進捗状態の遷移制御
     - イベント駆動型の状態更新
     - トランザクション一貫性の確保
   - **ナビゲーション決定エンジン**
     - 次のステップ候補の計算アルゴリズム
     - 推奨パス提示のロジック
     - カスタムルートの管理機能

3. **進捗追跡システム**
   - **進捗データ収集**
     - ユーザーアクション監視
     - 明示的・暗黙的な進捗指標の追跡
     - 時間ベースのメトリクス収集
   - **進捗状態計算**
     - プログラム全体の進捗率計算
     - 完了予測アルゴリズム
     - 進捗のマイルストーン検出
   - **可視化コンポーネント**
     - プログレスインジケータ
     - タイムライン表示機能
     - ダッシュボード集計ビュー

4. **依存関係解決システム**
   - **依存グラフ構築**
     - ステップ間の依存関係の静的分析
     - 依存関係の循環検出とバリデーション
     - 依存グラフの最適化
   - **実行時依存解決**
     - 動的な依存条件評価
     - 条件付き依存関係の処理
     - 依存関係変更時の影響範囲計算
   - **依存関係可視化**
     - 依存グラフの視覚的表現
     - ユーザー向け前提条件表示
     - 管理者向け依存編集インターフェース

5. **成果物管理システム**
   - **成果物生成パイプライン**
     - AIとの対話からの成果物抽出
     - フォーマット変換と正規化
     - 品質検証と評価
   - **成果物バージョン管理**
     - リビジョン履歴の追跡
     - 差分比較機能
     - ロールバック機能
   - **成果物統合システム**
     - 複数ステップの成果物結合
     - コンテクスト保持結合アルゴリズム
     - 最終成果物のコンパイル処理

6. **ステップUI/UX構成**
   - **ステップナビゲーションUI**
     - 階層型ナビゲーションコンポーネント
     - 進捗状態の視覚的表現
     - アクセス可否の視覚的フィードバック
   - **ステップ詳細表示**
     - コンテンツレイアウト構成
     - 補助リソース（動画、参考資料）の統合表示
     - インタラクティブ要素の配置
   - **ステップ移行インターフェース**
     - 次/前ステップナビゲーション
     - スキップ・復習オプション
     - 条件未達成時のフィードバック表示

このアーキテクチャにより、ユーザーは体系的かつ効率的に学習・作業を進められると同時に、管理者は柔軟なプログラム構成と詳細な進捗追跡を実現できます。

### プロンプト管理アーキテクチャ

AIとの対話品質を一貫して確保するためのプロンプト管理システムは、以下のアーキテクチャで構成されます：

1. **プロンプトデータモデル**
   - **コアエンティティ**
     - PromptTemplate（基本テンプレート）
     - PromptVersion（バージョン管理）
     - PromptVariable（動的変数定義）
   - **プロンプト分類**
     - プロンプトタイプ（開始時/継続時/チェック時/成果物作成時）
     - 対象ステップの関連付け
     - 使用言語と地域情報
   - **メタデータ**
     - バージョン履歴と変更記録
     - 作成者・更新者情報
     - 効果測定メトリクス

2. **バージョン管理システム**
   - **バージョニングストラテジー**
     - セマンティックバージョニングの適用
     - ブランチ/タグの概念によるバージョン組織化
     - 同時編集の競合解決メカニズム
   - **変更履歴管理**
     - 差分記録と比較機能
     - 変更理由のアノテーション
     - 監査証跡の維持
   - **バージョン間移行**
     - アクティブバージョンの切り替え
     - ロールバック機能
     - 複数バージョンの並行テスト

3. **変数置換エンジン**
   - **変数解析パーサー**
     - テンプレート構文の解析
     - 変数の抽出と検証
     - 構文エラーの検出
   - **コンテキスト収集**
     - プロジェクト情報の取得
     - 過去ステップの成果物参照
     - ユーザープロファイル情報収集
   - **動的置換処理**
     - 型安全な変数マッピング
     - デフォルト値とフォールバック処理
     - 条件付き置換ロジック

4. **プロンプト選択アルゴリズム**
   - **コンテキストベース選択**
     - 対話状況の分析
     - ユーザーの進捗状態評価
     - プロジェクト特性の考慮
   - **A/Bテスト統合**
     - ランダム割り当て機能
     - バリアント追跡システム
     - コンバージョン測定機構
   - **最適化フィードバックループ**
     - 効果測定メトリクス収集
     - パフォーマンス評価アルゴリズム
     - 自動/半自動の最適化提案

5. **管理者向け編集インターフェース**
   - **プロンプトエディター**
     - 構文ハイライト付きエディター
     - 変数補完機能
     - リアルタイムバリデーション
   - **テストツール**
     - 仮想対話環境でのプレビュー
     - テストケースの定義と実行
     - A/Bテスト管理インターフェース
   - **パフォーマンスダッシュボード**
     - 利用統計の可視化
     - バージョン間の比較分析
     - ユーザーフィードバック集計

6. **セキュリティと権限管理**
   - **アクセス制御**
     - ロールベースの権限設定
     - 編集・閲覧・適用の権限分離
     - 監査ログの維持
   - **機密情報保護**
     - センシティブ変数の安全な取り扱い
     - プロンプトの暗号化保存
     - アクセスログの追跡

このアーキテクチャにより、高品質かつ一貫したAI対話体験を提供すると同時に、継続的な改善と最適化のサイクルを確立できます。

### ビデオコンテンツ管理アーキテクチャ

ステップ学習を補完する教育ビデオリソースを効率的に管理・提供するビデオコンテンツ管理システムは、以下のアーキテクチャで構成されます：

1. **ビデオデータモデル**
   - **コアエンティティ**
     - VideoResource（ビデオリソース定義）
     - VideoMetadata（詳細メタデータ）
     - WatchProgress（視聴進捗情報）
   - **分類と関連付け**
     - ステップとの関連付け
     - タグとカテゴリ分類
     - シリーズとシーケンス管理
   - **提供元情報**
     - プロバイダータイプ（YouTube/Vimeo/内部ホスティング）
     - ソースURLと埋め込み情報
     - プロバイダー固有のメタデータ

2. **マルチプロバイダー統合レイヤー**
   - **プロバイダー抽象化**
     - 統一インターフェースの定義
     - プロバイダー固有の実装
     - プロバイダー検出と自動マッピング
   - **埋め込みコード生成**
     - プロバイダー別の最適化されたコード生成
     - レスポンシブ設定の適用
     - パラメータカスタマイズ（自動再生、UI制御など）
   - **メタデータ同期**
     - 外部プロバイダーからのメタデータ取得
     - 定期的な同期処理
     - 整合性検証

3. **視聴進捗追跡システム**
   - **進捗データ収集**
     - 再生イベントの追跡
     - 視聴時間と割合の計算
     - シーク・一時停止行動の記録
   - **状態管理**
     - 未視聴/部分視聴/完了の状態定義
     - 複数デバイス間での進捗同期
     - オフライン視聴とデータ同期
   - **分析ダッシュボード**
     - 視聴パターン分析
     - エンゲージメント指標の計算
     - ユーザー行動インサイト

4. **ビデオプレーヤーインフラストラクチャ**
   - **統一プレーヤーコンポーネント**
     - プロバイダーに依存しない再生インターフェース
     - 拡張制御（再生速度、字幕、品質設定）
     - モバイル最適化された再生環境
   - **プレーヤーカスタマイズ**
     - ブランディング適用
     - 機能拡張（注釈、インタラクティブ要素）
     - アクセシビリティ対応
   - **プレイリスト機能**
     - 連続再生の制御
     - 関連ビデオの自動提案
     - カスタムプレイリスト作成

5. **コンテンツ配信最適化**
   - **アダプティブストリーミング**
     - 帯域幅に応じた品質調整
     - プリロードと先読み戦略
     - バッファリング最適化
   - **CDN統合**
     - グローバルエッジ配信
     - キャッシング戦略
     - 地域別の最適化
   - **オフラインアクセス**
     - ダウンロード管理
     - ストレージ効率の最適化
     - 権限とアクセス期限の管理

6. **管理者向けツール**
   - **アップロードと管理インターフェース**
     - バルクアップロードと一括編集
     - メタデータエディター
     - サムネイル管理
   - **分析レポーティング**
     - 視聴統計ダッシュボード
     - 人気コンテンツ分析
     - エンゲージメント測定
   - **コンテンツ公開ワークフロー**
     - 承認プロセス
     - スケジュール公開
     - アクセス制御設定

このアーキテクチャにより、多様なソースからのビデオコンテンツを統一されたユーザー体験で提供しつつ、学習進捗と統合された視聴管理を実現します。

### 歴史的事例分析システムアーキテクチャ

ビジネスプランのリスク評価と改善提案を行うための歴史的事例分析システムは、以下のアーキテクチャコンポーネントで構成されます。

1. **事例データベース**
   - 成功・失敗事例の構造化データストレージ
   - 事例のベクトル表現とセマンティック検索
   - メタデータによる分類と索引付け
   - 時系列データの効率的な保存と検索
   
2. **分析エンジン**
   - パターンマッチングアルゴリズム
   - 機械学習ベースの分類モデル
   - 類似度計算とクラスタリング機能
   - 時系列分析と予測モデル
   - ルールベースの評価システム
   
3. **コンテキスト適応機構**
   - ユーザープロジェクトの特性抽出
   - 業界・セクター固有の評価ルール適用
   - 状況に応じた分析パラメータ調整
   - 段階的な詳細度制御
   
4. **レポーティングシステム**
   - リスク視覚化コンポーネント
   - 対話型の分析結果探索インターフェース
   - エビデンスベースの改善提案生成
   - カスタマイズ可能なレポートテンプレート

5. **AIアシスト統合**
   - GPTモデルによる改善提案の自然言語生成
   - ユーザー質問に対する説明生成
   - 分析結果解釈の支援
   - 提案のパーソナライズと具体化

## 型定義戦略

AiStartでは型安全性を最優先し、各レイヤーに適切な型定義を配置して、重複を避けつつ責務の明確な分離を実現します。型定義の基本方針、共通型、レイヤー間の型変換ルール、データベーススキーマ定義については、[05_type_definitions.md](/docs/restructuring/05_type_definitions.md) を参照してください。

### 型階層の概要

本アーキテクチャでは以下の型階層構造を採用しています：

- **ドメイン層**: 値オブジェクト、エンティティなどの純粋なドメインモデル型
- **アプリケーション層**: DTOおよびアプリケーション固有型
- **インフラストラクチャ層**: DBスキーマ型
- **プレゼンテーション層**: UI状態型、API入出力型

詳細な型定義、命名規則、型変換パターン、共通型については[05_type_definitions.md](05_type_definitions.md)に集約されています。

### 推奨ディレクトリ構造

ゼロから最適化したディレクトリ構造を以下のように提案します。この構造は、コンポーネントの再利用性、責務の分離、保守性の向上を目指して設計されています。

```
app/                      # Next.js App Router
├── (auth)/               # 認証関連ルート (グループ)
├── (dashboard)/          # ダッシュボード関連ルート (グループ)
├── api/                  # API Routes
└── [...locale]/          # 国際化ルート

domain/                   # ドメイン層
├── models/               # ドメインモデル (概念ごとにグルーピング)
│   ├── user/             # Userドメイン関連ファイル群
│   │   ├── user.entity.ts
│   │   ├── user-id.vo.ts
│   │   ├── email.vo.ts
│   │   └── user-role.enum.ts
│   ├── ai-prompt/        # AI Promptドメイン関連ファイル群
│   │   ├── ai-prompt.entity.ts
│   │   ├── prompt-id.vo.ts
│   │   ├── prompt-category.enum.ts
│   │   └── ai-model-type.enum.ts
│   └── ...               # 他のドメインモデル
├── services/             # ドメインサービス (必要に応じてドメインフォルダ内に配置も検討)
├── repositories/         # リポジトリインターフェース (必要に応じてドメインフォルダ内に配置も検討)
└── events/               # ドメインイベント (必要に応じてドメインフォルダ内に配置も検討)

application/              # アプリケーション層
├── usecases/             # ユースケース
└── dtos/                 # データ転送オブジェクト

infrastructure/           # インフラストラクチャ層
├── database/             # データベース関連
│   ├── schema/           # Drizzle Schema
│   ├── migrations/       # DBマイグレーション
│   └── repositories/     # リポジトリ実装
├── ai/                   # AI関連
│   ├── providers/        # 各AIプロバイダーの実装
│   ├── adapters/         # AIアダプター
│   └── prompt-templates/ # プロンプトテンプレート
├── mappers/              # データマッパー
├── auth/                 # 認証・認可
└── external-services/    # 外部サービス連携

presentation/             # プレゼンテーション層
├── components/           # Reactコンポーネント
│   ├── common/           # 共通コンポーネント
│   ├── layouts/          # レイアウトコンポーネント
│   ├── forms/            # フォームコンポーネント
│   └── feature-specific/ # 機能固有コンポーネント
├── hooks/                # Reactフック
├── providers/            # コンテキストプロバイダー
└── utils/                # プレゼンテーション層のユーティリティ

shared/                   # 共有リソース
├── types/                # 共通型定義
├── utils/                # 共通ユーティリティ関数
├── constants/            # 定数
└── errors/               # エラー定義

config/                   # アプリケーション設定
├── environment.ts        # 環境変数処理
├── feature-flags.ts      # 機能フラグ
└── app-config.ts         # アプリ設定

i18n/                     # 国際化リソース
├── locales/              # 言語リソース
├── config.ts             # i18n設定
└── types/                # i18n関連型定義

tests/                    # テスト
├── unit/                 # 単体テスト
├── integration/          # 統合テスト
└── e2e/                  # E2Eテスト
```

この構造は以下の利点を持ちます：

1. **型定義の重複を回避**：型定義は各レイヤーの実装と一緒に配置
2. **関心の明確な分離**：各レイヤーとドメイン機能の責務を明確に定義
3. **保守性の向上**：関連するコードが近くに配置され、変更が容易
4. **スケーラビリティ**：機能追加が容易で、機能別の整理が一貫
5. **Next.jsとの統合**：Next.jsのApp Routerと自然に統合
6. **シンプルなルートパス**：`src/`ディレクトリを介さないシンプルなインポートパス

## 技術スタック選定

### フロントエンド

**フレームワーク: Next.js (React 18+)**
- App Routerアーキテクチャによるファイルベースルーティング
- サーバーコンポーネントとクライアントコンポーネントの適切な使い分け
- 静的生成（Static Generation）と動的レンダリングの選択的適用

**UI構築: Tailwind CSS + shadcn/ui**
- ユーティリティファーストCSSフレームワークによる効率的なUI実装
- コンポーネントライブラリとしてshadcn/uiを活用（カスタマイズ性重視）
- アイコンライブラリとしてlucide-reactを統一使用

**状態管理: React Context API + TanStack Query + Jotai (補助)**
- グローバルで頻繁に更新されない状態（テーマ、ユーザー設定など）はReact Context APIで管理
- サーバー状態のキャッシュ、同期、非同期データ取得はTanStack Query (旧React Query) で管理
  - `staleTime` と `cacheTime` を適切に設定し、不要な再取得を抑制
  - Query Key の命名規則は [04_implementation_rules.md](/docs/restructuring/04_implementation_rules.md) を参照
- コンポーネント間で共有されるクライアントサイドの揮発性状態（フォーム入力状態、UI制御フラグなど）は Jotai を補助的に使用
  - Context APIよりも細粒度な状態管理が必要な場合に限定的に利用
  - Atom のスコープは最小限に留める

**フォント管理:**
- 英語コンテンツ: Hanken Grotesk
- 日本語コンテンツ: Noto Sans JP
- Next.jsの組み込みフォント最適化を活用

### バックエンド

**サーバーランタイム: Node.js v22 LTS (Jod)**
- TypeScriptによる型安全な実装
- モジュール分割と責務の明確化によるメンテナンス性向上

**依存性注入 (DI): tsyringe**
- 宣言的なDIによるコンポーネント結合度の低減
- `@injectable`デコレータを活用したクラス自動登録
- インターフェースと実装の明確な分離 (主にインフラ層のリポジトリ実装などで活用)
- アプリケーション層のユースケースやドメインサービスへの依存性注入
- テスト容易性の向上とモック置換の簡素化
- コンテナ設定とスコープ管理の詳細は [04_implementation_rules.md](/docs/restructuring/04_implementation_rules.md) を参照

**API実装: Next.js API Routes + Edge Runtime**
- RESTfulなエンドポイント設計
- Route Handlersによる効率的なAPI実装
- 認証・認可はミドルウェアで一元管理

**データベース: PostgreSQL (via Supabase)**
- リレーショナルデータモデルの活用
- pgvector拡張によるベクトル検索機能
- Row Level Security (RLS)による行レベルのアクセス制御

**ORM: Drizzle ORM**
- 型安全なクエリビルダー
- マイグレーション管理（Drizzle Kit）
- 低オーバーヘッドで高パフォーマンス

**認証: Auth.js**
- OAuth2+OIDCベースの認証（Auth.js）
- 主要プロバイダー: Google, GitHub, Microsoft
- セッション管理: セキュアなJWT（HttpOnly Cookie）

### AI統合

**マルチモデルアーキテクチャ**
- マルチプロバイダー対応の抽象化レイヤー
- モデル切替機能によるAIプロバイダー間の透過的な切り替え
- コンテキスト依存のAIモデル選択ロジック

**対応AIプロバイダー**
- **OpenAI**: GPT-4o、GPT-3.5、GPT-o3-mini（小規模で効率的）
- **Anthropic**: Claude-3.7-sonnet（文脈理解に優れたモデル）
- **Google**: Gemini-2.5-pro（マルチモーダル対応）
- **その他オープンソースモデル**: Ollama経由でのローカルモデル実行（プライバシー重視）

**AIオーケストレーション**
- モデル選択戦略（コスト、性能、速度の最適化）
- フォールバックメカニズム（モデル障害時の代替手段、詳細は「エラーハンドリングアーキテクチャ」参照）
- リトライ戦略（詳細は「リトライメカニズムと回復戦略」参照）
- リクエスト分配と負荷分散
- 使用量モニタリングとコスト最適化

**ベクトルデータベース: PostgreSQL + pgvector**
- 埋め込みベクトルの効率的な保存と検索
- 類似度検索によるコンテキスト検索の最適化
- 複数埋め込みモデル対応（OpenAI、Cohere、Sentence Transformers等）

### 開発環境

**コードエディタ: Cursor**
- AIアシスト機能を活用した効率的な開発
- TypeScript型チェックと統合された開発体験
- コードコンテキスト理解に基づく補完機能

**バージョン管理: GitHub**
- プルリクエストベースの協業
- コードレビュー・イシュー管理の一元化
- GitHub Actionsによる自動化

**CI/CD: GitHub Actions + Vercel**
- コード品質チェック自動化（ESLint, TypeScript型チェック）
- テスト自動実行（Jest, Cypress）
- Vercelへの自動デプロイ連携

**依存関係管理**
- package.json：Node.js依存パッケージの明示的な管理
- npm（または yarn、pnpm）：パッケージ依存関係の一貫した解決
- 依存バージョン指定方針：
  - 主要フレームワーク（Next.js、React）：メジャーバージョン固定（^14.0.0、^18.0.0）
  - 重要ライブラリ：マイナーバージョン固定（~4.5.0）
  - 開発ツール：最新版自動更新（latest）
- package-lock.json（または yarn.lock、pnpm-lock.yaml）によるロックファイル管理

### 国際化（i18n）技術

**ライブラリ: next-intl**
- Next.js向けの最適化された国際化ライブラリ
- App Routerとの統合による効率的なルーティング
- メッセージの型安全な取り扱い
- フォールバックロケール機能とリソース集約

**言語リソース管理:**
- JSON形式による階層的リソース構造
- 言語別のコード分割とオンデマンドローディング
- 型安全な翻訳キーアクセス（TypeScript型の自動生成）
- 翻訳管理ツールとの統合（内製または外部サービス）

**フォーマット機能:**
- ICU MessageFormat対応のプレースホルダー処理
- 日付、数値、通貨などのロケールに応じたフォーマッタ
- 単位や複数形の言語固有ルールの適用
- 方向性（LTR/RTL）の自動切り替え

**パフォーマンス最適化:**
- 言語リソースの動的インポートとコード分割
- サーバーコンポーネントでの翻訳処理最適化
- クライアントサイドのキャッシュ戦略
- 優先言語の高速検出と適用

### 歴史的事例分析技術

**データ管理:**
- **ベクトルストア:** pgvector（PostgreSQL拡張）
- **データ構造化:** Zod/TypeScript型による一貫した事例構造
- **分類システム:** 階層的タグ付けとメタデータ
- **データソース:** バッチインポート機能とAPI連携

**分析エンジン:**
- **類似性検索:** コサイン類似度による事例マッチング
- **分類モデル:** アンサンブル決定木（ランダムフォレスト）
- **パターン抽出:** 教師あり学習モデルとルールベースハイブリッド
- **予測モデル:** 時系列分析と回帰モデル
- **NLP処理:** 埋め込みベクトルによるセマンティック解析

**視覚化コンポーネント:**
- **グラフAPI:** Recharts/D3.js
- **リスクヒートマップ:** カスタムビジュアライゼーション
- **インタラクティブダッシュボード:** React Gridレイアウト
- **レポートエクスポート:** PDF/CSVエクスポート機能

**AI統合:**
- **コンテキスト生成:** 歴史的事例データからのAIプロンプト強化
- **説明生成:** 選択されたAIモデルによる対話式の分析結果説明
- **改善提案:** ルールベースとAI生成の組み合わせ
- **参照システム:** 歴史的事例へのエビデンスリンク

## モジュール分割・依存関係

### ドメイン層（Domain Layer）

ビジネスロジックの中心となる層です。外部依存を持たず、純粋なドメインロジックのみを含みます。

**主な構成要素**
- `domain/models/`: ドメインモデルのルートディレクトリ。
  - `{domain-name}/`: 各ドメイン概念 (例: `user`, `ai-prompt`) ごとにファイルを格納するディレクトリ。Entity, Value Object, Enum など、そのドメインに関連する型やクラスをフラットに配置します。
- `domain/services/`: ドメインサービス。複数のエンティティや値オブジェクトにまたがるドメインロジックをカプセル化します。（注: 特定のドメインに強く関連する場合は、`domain/models/{domain-name}/` 内に配置することも検討します。）
- `domain/events/`: ドメインイベント。ドメイン内で発生した重要な出来事を表現します。（注: 配置場所は `services` と同様に検討します。）
- `domain/repositories/`: リポジトリインターフェース（ポート）。ドメインオブジェクトの永続化に関する操作を定義します。（注: 配置場所は `services` と同様に検討します。）

**役割と責務**
- ビジネスルールとロジックを定義
- 他の層からの独立性を保ち、外部依存を持たない
- リポジトリインターフェースを通じて永続化の抽象化を提供

### アプリケーション層（Application Layer）

ユースケースを実装し、ドメイン層とインフラストラクチャ層を橋渡しします。

**主な構成要素**
- `application/usecases/`: ユースケース実装（機能別にサブディレクトリ化）
- `application/dtos/`: データ転送オブジェクト

**役割と責務**
- ユーザーの意図（ユースケース）を実装
- ドメインオブジェクトを操作してビジネスロジックを実行
- トランザクション制御やセキュリティチェックを担当
- 入出力データの変換（DTOの使用）

### インフラストラクチャ層（Infrastructure Layer）

外部サービスとの連携やデータの永続化を担当します。

**主な構成要素**
- `infrastructure/database/`: データベース関連
  - `schema/`: DB定義（Drizzle Schema、詳細は [05_type_definitions.md](/docs/restructuring/05_type_definitions.md)）
  - `repositories/`: リポジトリ実装（ドメイン層のインターフェースを実装）
  - `read-models/`: QueryObject/ReadModel の実装（読み取り専用クエリ）
- `infrastructure/mappers/`: データ変換ロジック（機能別に整理）
- `infrastructure/auth/`: 認証・認可実装
- `infrastructure/ai/`: AI統合実装 (プロバイダーアダプター、エラーハンドリング含む)

**役割と責務**
- ドメイン層で定義されたリポジトリインターフェースの実装を提供
- 外部サービス（DB、AI、認証等）との統合
- データの永続化と取得
- モデル間のマッピング（DB ⇔ ドメインモデル、ドメインモデル ⇔ DTO）

### プレゼンテーション層（Presentation Layer）

ユーザーインターフェースとAPIエンドポイントを提供します。

**主な構成要素**
- `presentation/api/`: API定義（機能別にサブディレクトリ化）
- `presentation/ui/`: Web UI
  - `components/`: UIコンポーネント（共通・機能別に整理）
  - `hooks/`: Reactフック
  - `contexts/`: Reactコンテキスト
  - `types/`: UI固有の型定義

**役割と責務**
- ユーザーインターフェースの提供（UI、API）
- ユーザー入力の処理と検証
- アプリケーション層のユースケース呼び出し
- レスポンスのフォーマットと表示

### Next.js App Router統合

Next.jsのApp Routerは、プレゼンテーション層の実際の実装として機能します。

**主な構成要素**
- `app/`: Next.jsのルーティング・ページ実装
  - グループ化されたルート（例: `(dashboard)/`）
  - API Routes（`app/api/`）
  - レイアウトとページコンポーネント

**役割と責務**
- ルーティング構造の定義
- ページレイアウトの構成
- サーバーコンポーネントとクライアントコンポーネントの組み合わせ
- プレゼンテーション層のUIとAPIの実装

**app/とpresentation/uiの関係**
- `app/`：Next.jsのファイルベースルーティングを使用したページとレイアウト
  - ページやレイアウト内で`presentation/ui/components`からコンポーネントをimport
  - ルーティング、ミドルウェア、レイアウト定義を担当
  - SSR、SSG、ISRなどのレンダリング戦略を定義
- `presentation/ui`：再利用可能なUIコンポーネントとロジック
  - ページの構成要素となるUIコンポーネントを提供
  - 純粋なUI関連のロジック（hooks、contexts）を管理
  - ページに依存しない形で実装し、複数ページから再利用可能

**実装パターン例**については、[コード例集](/docs/restructuring/code_examples/02_architecture_design_examples.md)を参照してください。

### 依存関係の方向性

依存関係は内側に向かうように設計します。

```
Presentation → Application → Domain ← Infrastructure
```

- ドメイン層は他のどの層にも依存しない
- アプリケーション層はドメイン層のみに依存
- インフラストラクチャ層はドメイン層のインターフェース（ポート）に依存
- プレゼンテーション層はアプリケーション層のユースケースに依存

### マッパーとリポジトリの違い

**リポジトリ（Repository）**
- **ドメイン層のリポジトリ**（`domain/repositories/`）
  - インターフェースのみを定義（実装なし）
  - ドメインオブジェクトの保存・取得・検索操作を定義
  - データソースの詳細を抽象化
  
- **インフラ層のリポジトリ**（`infrastructure/database/repositories/`）
  - ドメイン層で定義されたインターフェースの具体的な実装
  - PostgreSQLやその他のデータソースとの実際の接続・操作
  - マッパーを利用してデータ変換を行う

**マッパー（Mapper）**
- **インフラ層のマッパー**（`infrastructure/mappers/`）
  - 異なるデータ表現間の変換ロジックを提供
  - 変換の種類:
    1. DBスキーマ → ドメインモデル
    2. ドメインモデル → DB保存用データ
    3. ドメインモデル → DTO（API応答用）
  - リポジトリ内から呼び出され、データ変換のロジックを分離

## 共有リソースと設定の区分

アプリケーション内の共有リソースと設定を明確に区分し、それぞれの責任範囲を定義します。

## データフロー・インフラ構成

### データフローの概要

**基本的なデータフロー**

1. ユーザーリクエスト → Next.js App Router (サーバーコンポーネント or クライアントコンポーネント) / API Routes
2. SC/CC/API Routes → ユースケース（アプリケーション層、必要に応じてDIコンテナから取得）
3. ユースケース → ドメインサービス/エンティティ（ドメイン層）
4. ドメインロジック → リポジトリ（インターフェース）
5. リポジトリ実装（インフラストラクチャ層、DIにより注入） → PostgreSQL (Drizzle ORM) / QueryObject (ReadModel)
6. 結果を逆方向に伝播 (エラーは `Result` 型で伝播、詳細は「エラーハンドリングアーキテクチャ」参照)
   - インフラ層 → アプリケーション層 (DBエラーなどを `Result` でラップ)
   - アプリケーション層 → プレゼンテーション層 (ドメインエラー、アプリケーションエラーを `Result` でラップ)
7. プレゼンテーション層 → ユーザー (UI表示、APIレスポンス)

**AI対話フロー**

1. ユーザー入力 → Next.js API Routes or Server Action
2. プロンプト構築（アプリケーション層のユースケース）
3. ドメインコンテキスト取得（リポジトリ経由）
4. AI対話実行（インフラ層の AI アダプター経由、エラーハンドリング・リトライ含む）
5. 結果処理と保存（ドメイン層 → リポジトリ）
6. レスポンス返却 → ユーザー (ストリーミング、エラーは `Result` で処理)

### インフラ構成

**開発環境**
- ローカル開発: Next.js dev + Supabase CLI
- テスト環境: Vercelプレビュー + Supabase開発プロジェクト

**本番環境**
- フロントエンド/API: Vercel（本番）
- データベース: Supabase PostgreSQL（本番）
- ストレージ: Vercel Blob Storage（主要）+ Supabase Storage（補助）
- キャッシュ: Upstash Redis
- CDN: Vercelエッジネットワーク

**CI/CD**
- GitHub連携: プッシュやPRごとの自動ビルド・デプロイ
- 自動テスト: GitHub Actions
- データベースマイグレーション: Drizzle Kit + GitHub Actions

### 国際化データフロー

国際化機能のデータフロー図を以下に示します：

```
[クライアント]           [サーバー]                    [ストレージ]
   |                        |                             |
   |-- 言語設定要求 ------>|                             |
   |                        |-- 言語設定保存 ----------->| ユーザー設定DB
   |                        |                             |
   |-- ページ要求 --------->|                             |
   |                        |-- 言語設定取得 ----------->| ユーザー設定DB
   |                        |<- 言語設定返却 ------------| 
   |                        |                             |
   |                        |-- 言語リソース取得 -------->| 言語リソースバンドル
   |                        |<- 言語リソース返却 ---------| 
   |                        |                             |
   |<- レンダリング済HTML --| (サーバーコンポーネント)    |
   |                        |                             |
   |-- 追加リソース要求 --->|                             |
   |                        |-- 言語リソース取得 -------->| 言語リソースバンドル
   |<- 追加リソース返却 ----|<- 言語リソース返却 ---------| 
   |                        |                             |
```

#### 歴史的事例分析データフロー

歴史的事例分析システムのデータフロー図を以下に示します：

```
[ビジネスプラン]       [分析エンジン]             [データストア]
      |                      |                        |
      |-- プラン送信 ------->|                        |
      |                      |-- 類似事例検索 ------->| 事例データベース
      |                      |<- 類似事例返却 --------| 
      |                      |                        |
      |                      |-- パターン抽出 ------->| 分析モデルDB
      |                      |<- パターン返却 --------| 
      |                      |                        |
      |                      |-- リスク評価計算       |
      |                      |-- 成功確率予測         |
      |                      |-- 改善提案生成 ------->| GPTサービス
      |                      |<- 生成提案返却 --------| 
      |                      |                        |
      |<- 分析レポート返却 --|                        |
      |                      |-- 分析結果保存 -------->| 分析履歴DB
      |                      |                        |
```

## セキュリティ設計

### 認証認可方式

**認証方式**
- OAuth2+OIDCベースの認証（Auth.js）
- 主要プロバイダー: Google, GitHub, Microsoft
- セッション管理: セキュアなJWT（HttpOnly Cookie）

**認可方式**
- ロールベースアクセス制御（RBAC）を基本とします。
- **主要なロール定義**: ([05_type_definitions.md](/docs/restructuring/05_type_definitions.md) に詳細定義想定)
  - **管理者（Admin）**: システム全体の管理権限。**原則として管理者専用API (`/api/admin/v1` 等) を使用します。**
  - **編集者（Editor）** (例): 特定コンテンツの編集・承認権限など、一般ユーザーより広い権限を持つ中間ロール。
  - **一般ユーザー（User）**: 自身のデータ操作とサービス利用権限。
- **APIエンドポイントと認可**: ([07_server_implementation.md](/docs/restructuring/07_server_implementation.md) に詳細実装方針)
  - **管理者専用操作**: `/api/admin/v1` プレフィックスを持つエンドポイントを使用します。このプレフィックス下のAPIは `Admin` ロールを持つユーザーのみアクセス可能です。
  - **一般ユーザーおよび中間ロール (`Editor` 等) の操作**: 原則として `/api/v1` プレフィックスを持つエンドポイントを使用します。特定のエンドポイントやHTTPメソッドへのアクセス権限は、**ミドルウェア層**で要求されるロール（例: `User`, `Editor`, `Admin` のいずれか、または `Editor` 以上など）に基づいて厳格にチェックされます。APIハンドラ内部での複雑なロール分岐は極力避けます。
- **リソース所有権**: 一般ユーザーの操作では、リソース（例: Project）の所有権チェックも重要になります。
- **データベースレベル**: PostgreSQL Row Level Security (RLS) も併用し、データアクセス層でのセキュリティを強化します。RLSポリシーはユーザーIDやロールに基づいて定義されます。

### データ保護

**保存データ**
- 機密情報の暗号化（AES-256、詳細は[04_implementation_rules.md](/docs/restructuring/04_implementation_rules.md)のセキュリティセクション参照）
- 個人情報の最小限の収集と匿名化
- データベースレベルでのRow Level Security適用

**通信データ**
- TLS 1.3による全通信の暗号化
- 安全なAPIトークン管理（有効期限、更新戦略）
- サーバーコンポーネントとクライアントコンポーネント間の安全なデータ転送（[04_implementation_rules.md](/docs/restructuring/04_implementation_rules.md)参照）

**バックアップとリカバリ**
- 定期的な自動バックアップ（日次/週次/月次）
- ポイントインタイムリカバリ（PITR）
- データ復旧手順の文書化と定期テスト

### 脆弱性対策

**実装レベル**
- 入力検証とサニタイゼーション（Zod）
- CSRF対策（SameSite Cookie）
- XSS対策（Reactのエスケープ機能、CSP）
- HTTPS強制（Strict-Transport-Security）

**運用レベル**
- 依存パッケージの脆弱性スキャン（npm audit）
- 定期的なセキュリティレビュー
- レスポンスヘッダー最適化（Helmet.js等）

## アーキテクチャ図

### システムアーキテクチャ概要

```
┌──────────────────────────┐     ┌─────────────────────────┐
│                          │     │                         │
│   クライアント (ブラウザ)    │     │     ドメインモデル      │
│                          │     │                         │
└───────────────┬──────────┘     │  ┌─────────────────┐    │
                │                   │  │   Conversation  │    │
                ▼                   │  │    (エンティティ)   │    │
┌──────────────────────────┐     │  └─────────────────┘    │
│                          │     │  ┌─────────────────┐    │
│    プレゼンテーション層     │     │  │     Message     │    │
│    (Next.js App Router)    │     │  │    (Value Object) │    │
│                          │     │  └─────────────────┘    │
└───────────────┬──────────┘     │  ┌─────────────────┐    │
                │                   │  │     Prompt      │    │
                ▼                   │  │    (エンティティ)   │    │
┌──────────────────────────┐     │  └─────────────────┘    │
│                          │     │                         │
│     アプリケーション層     │     └─────────────────────────┘
│     (ユースケース)        │
│                          │     ┌─────────────────────────┐
└───────────────┬──────────┘     │                         │
                │                   │     リポジトリ層        │
                ▼                   │                         │
┌──────────────────────────┐     │  ┌─────────────────┐    │
│                          │     │  │ConversationRepo │    │
│       ドメイン層          │     │  │                 │    │
│  (モデル・ビジネスロジック)  │     │  │                 │    │
│                          │     │  └─────────────────┘    │
└─────┬─────────────┬──────┘     │  │  PromptRepo     │    │
      │             │           │  │                 │    │
      │             │           │  └─────────────────┘    │
┌─────▼─────┐ ┌─────▼─────┐     │                         │
│           │ │           │     └─────────────────────────┘
│ 外部API連携 │ │リポジトリ  │
│ (GPT-o3-mini)│ │インターフェース│
│           │ │           │
└─────┬─────┘ └─────┬─────┘
      │             │
      │             │
┌─────▼─────┐ ┌─────▼─────┐
│           │ │           │
│ OpenAI API │ │インフラストラクチャ層│
│           │ │ (リポジトリ実装)  │
│           │ │           │
└───────────┘ └─────┬─────┘
                    │
                    ▼
          ┌──────────────────┐
          │                  │
          │  PostgreSQL      │
          │  (Supabase)      │
          │                  │
          └───────┬──────────┘
                  │
          ┌───────▼──────────┐
          │                  │
          │  ストレージサービス  │
          │  (Vercel Blob/   │
          │   Supabase Storage)│
          │                  │
          └──────────────────┘
```

## データマッピング例

データマッピングの具体例については、[コード例集](/docs/restructuring/code_examples/02_architecture_design_examples.md#データマッピング例)を参照してください。

## 機能要件とアーキテクチャの対応関係

AiStartの主要機能と実装アーキテクチャの対応関係を明確にします。これにより、各機能がどのレイヤーとコンポーネントで実装されるかを把握できます。

### 主要機能の実装マッピング

| 機能要件 | ドメイン層 | アプリケーション層 | インフラストラクチャ層 | プレゼンテーション層 |
|---------|----------|-----------------|-------------------|-----------------|
| **ユーザー認証・管理 (一般)** | User, Role (entities) | UserUsecase, AuthUsecase | AuthRepository, UserRepository, AuthService | AuthUI, ProfileUI |
| **ユーザー管理 (管理者)** | User, Role (entities) | **AdminUserUsecase** | UserRepository, RoleRepository | **AdminUserManagementUI** |
| **プログラム管理 (一般)** | Program, Category (entities) | ProgramQueryService | ProgramRepository, CategoryRepository | ProgramListUI, ProgramDetailUI |
| **プログラム管理 (管理者)** | Program, Category (entities) | **AdminProgramUsecase** | ProgramRepository, CategoryRepository | **AdminProgramManagementUI** |
| **ステップ管理 (一般)** | Step, StepCondition (entities) | StepQueryService | StepRepository, StepConditionRepository | StepViewerUI |
| **ステップ管理 (管理者)** | Step, StepCondition (entities) | **AdminStepUsecase** | StepRepository, StepConditionRepository | **AdminStepManagementUI** |
| **コンテンツ管理 (一般)** | Content, Prompt, Video (entities) | ContentQueryService | ContentRepository, StorageService | ContentViewUI |
| **コンテンツ管理 (管理者)** | Content, Prompt, Video (entities) | **AdminContentUsecase**, MediaUsecase | ContentRepository, StorageService | **AdminContentManagementUI**, MediaUploadUI |
| **プロジェクト管理 (一般)** | Project, ProjectStatus (entities) | ProjectUsecase | ProjectRepository | ProjectDashboardUI, ProjectEditorUI |
| **AI支援機能** | Conversation, AIContext (entities) | AIConversationUsecase | AIService, VectorRepository | ChatUI, AIAssistantUI |
| **サブスクリプション管理 (一般)** | Subscription, Plan (entities) | SubscriptionUsecase, BillingUsecase | SubscriptionRepository, PaymentService | SubscriptionUI, BillingUI |
| **サブスクリプションプラン管理 (管理者)** | Plan (entity) | **AdminPlanUsecase** | PlanRepository | **AdminPlanManagementUI** |
| **成果物管理** | Output, OutputVersion (entities) | OutputUsecase, ExportUsecase | OutputRepository, ExportService | OutputEditorUI, OutputViewerUI |
| **添付ファイル管理** | Attachment, AttachmentMetadata (entities) | AttachmentUsecase | AttachmentRepository, StorageService | AttachmentUploadUI, FileManagerUI |
| **管理ダッシュボード** | - | **AdminDashboardQueryService** | Various Repositories (ReadModels) | **AdminDashboardUI** |

**注:** 管理者向け機能 (`Admin*`) は、一般ユーザー向け機能とは別のユースケースやUIコンポーネントとして実装されることを想定しています。APIエンドポイントも `/api/admin/v1` のように分離される可能性があります。

### 機能実装フロー図

下記は、プログラム管理機能の実装フローを例として示しています：

```
【ユーザー】 ⟶ 【UI】            ⟶ 【API】                ⟶ 【ユースケース】         ⟶ 【ドメイン】           ⟶ 【リポジトリ】         ⟶ 【DB】
  |              |                   |                        |                         |                       |                      |
  |       components/program/   api/program/            application/usecases/    domain/models/entities/  infrastructure/database/  PostgreSQL
  |       ProgramList.tsx      program.route.ts        program/ProgramUsecase.ts program/Program.ts      repositories/ProgramRepo  (Supabase)
  |              |                   |                        |                         |                       |                      |
  |⟵ 応答 ⟵ components/program/ ⟵ api/program/          ⟵ DTO変換              ⟵ ドメインロジック処理    ⟵ マッパー変換          ⟵ クエリ結果
    (HTML)  ProgramDetail.tsx    GET /api/programs/:id   (ProgramDTO)            (Programエンティティ)    (DBレコード→エンティティ)
```

### レイヤー間のデータフロー

1. **ユーザーインタラクション**:
   - ユーザーがUIを操作（例：プログラム一覧表示ボタンをクリック）
   - Next.js App Routerによるルーティング処理

2. **APIリクエスト**:
   - プレゼンテーション層のUIコンポーネントがAPIを呼び出し
   - API Routeがリクエストを受け、バリデーション処理

3. **ユースケース実行**:
   - アプリケーション層のユースケースがビジネスロジックを調整
   - 必要に応じて複数のドメインサービスやリポジトリを組み合わせる

4. **ドメインロジック処理**:
   - ドメイン層のエンティティやサービスがビジネスロジックを実行
   - ドメインルールを適用し、結果を返却

5. **データアクセス**:
   - インフラストラクチャ層のリポジトリがデータ取得・保存を担当
   - マッパーを使用してDBレコードとドメインモデル間の変換

6. **レスポンス返却**:
   - データをDTOに変換し、APIレスポンスとして返却
   - UIコンポーネントが結果を受け取り、表示を更新

### 機能別ディレクトリ構造

機能ごとの詳細なディレクトリ構造例については、[コード例集](/docs/restructuring/code_examples/02_architecture_design_examples.md)を参照してください。

## AIサービス層の設計

AiStartにおけるAI対話機能は、ユーザーのビジネスプラン作成を支援する中核機能です。この機能を実現するためのアーキテクチャ設計を以下に示します。

### メッセージ構成アーキテクチャ

メッセージ構成コンポーネントの詳細やコード例については、[コード例集](/docs/restructuring/code_examples/02_architecture_design_examples.md#コンテキスト最適化)を参照してください。

### 会話種別に基づくコンテキスト構築とプロンプト選択

AiStartでは、ユーザーの目的に応じて最適な対話を提供するため、会話種別の概念を導入します。会話種別に基づいて異なるコンテキスト構築戦略とプロンプト選択ロジックを適用することで、より状況に適した対話体験を実現します。

#### 会話種別の定義

```typescript
// 会話種別を表す列挙型
enum ConversationType {
  INITIAL = 'initial',        // 開始時
  CONTINUOUS = 'continuous',  // 継続時
  CHECKPOINT = 'checkpoint',  // チェック時
  OUTPUT_CREATION = 'output_creation', // 成果物作成時
}
```

#### データモデルの拡張

会話種別に対応したデータモデルの拡張例については、[コード例集](/docs/restructuring/code_examples/02_architecture_design_examples.md#コンテキスト最適化)を参照してください。

#### コンテキスト構築の戦略パターン

会話種別ごとに異なるコンテキスト構築戦略を適用するための戦略パターン実装例については、[コード例集](/docs/restructuring/code_examples/02_architecture_design_examples.md#コンテキスト最適化)を参照してください。

### メッセージフロー設計

AIサービス層のメッセージフローは、会話種別を考慮して次のように拡張されています：

1. **ユーザー入力フェーズ**
   - ユーザーがUIからメッセージを入力
   - 会話種別の選択または自動判定
   - フロントエンドがメッセージと会話種別をAPI Routeに送信

2. **コンテキスト構築フェーズ**
   - 会話種別に応じた戦略を選択
   - 戦略に基づいてプロジェクト情報、ステップ情報、過去の成果物からコンテキストを構築
   - 会話種別に応じたトークン配分で最適化

3. **プロンプト選択フェーズ**
   - ステップタイプと会話種別の両方に基づいて適切なプロンプトテンプレートを選択
   - 選択されたテンプレートをコンテキスト情報で変数置換

4. **メッセージ履歴管理フェーズ**
   - 過去の対話履歴を取得
   - トークン制限を考慮して履歴をフィルタリング
   - 新しいユーザーメッセージを追加

5. **APIリクエスト構築フェーズ**
   - システムプロンプト、対話履歴、ユーザーメッセージを結合
   - トークン使用量を推定し必要に応じて最適化
     - 最大トークン上限: モデルの上限の80%を目標とする
     - 優先度の低いコンテクスト情報から削減（例: 古い会話履歴、詳細なステップ情報）
     - 重要なシステムプロンプトは常に保持
   - プロバイダー非依存の抽象化されたAPIリクエストの構築

6. **レスポンス処理フェーズ**
   - ストリーミングレスポンスの受信と処理
   - UIへの段階的な表示
   - 完了したレスポンスの履歴への保存
   - エラー発生時の適切なフォールバック処理（「エラーハンドリングアーキテクチャ」セクション参照）

### データモデル

AIサービス層のデータモデル例については、[コード例集](/docs/restructuring/code_examples/02_architecture_design_examples.md#コンテキスト最適化)を参照してください。

この設計により、AIとの対話に必要なコンテキスト情報（過去のステップ成果物、プロジェクト状態など）を効率的に管理し、ユーザーに一貫した対話体験を提供します。また、プロンプトテンプレートの管理とバージョニングにより、対話品質の継続的な改善と最適化が可能になります。

### エラーハンドリングアーキテクチャ

AIを活用したサービスでは、外部API依存による不確実性に対処するための堅牢なエラーハンドリング戦略が不可欠です。AiStartでは多層的なエラーハンドリングアーキテクチャを採用し、システムの回復力と可用性を確保します。

#### 1. エラー分類と対応戦略

| エラータイプ | 説明 | 対応戦略 |
|------------|------|---------|
| 一時的なAPIエラー | サービス過負荷、ネットワーク不安定などの一時的問題 | 指数バックオフによる自動リトライ（最大3回） |
| モデル制約エラー | トークン制限、コンテンツフィルターなどによる拒否 | コンテキスト削減、代替プロンプト使用 |
| プロバイダー障害 | 特定AIプロバイダーの完全な利用不可 | 代替プロバイダーへの自動フェイルオーバー |
| 入力検証エラー | 不正な入力パラメータ | 明確なエラーメッセージとUI修正ガイダンス |
| セッションエラー | 認証・認可の問題 | 自動再認証、セッションリフレッシュ |

#### 2. グレースフル・デグラデーション

サービス障害時に重要機能を維持するための段階的な機能低下戦略:

1. **完全機能モード**: すべての機能が正常動作
2. **制限機能モード**: 高度なAI機能の一部制限、基本機能は維持
3. **基本機能モード**: 事前生成されたコンテンツとキャッシュのみ使用
4. **静的コンテンツモード**: 静的情報のみ提供、動的処理は無効化

各アプリケーション機能はこれらのモードに対応した実装を持ち、システム状態に応じて適切なモードに自動切り替えします。

## 環境変数定義とアプリケーション設定

アプリケーション設定の一貫性と型安全性を確保するため、環境変数を体系的に管理します。Zodを使用した型検証と変数定義により、実行時エラーを事前に検出し、安全な設定管理を実現します。

### 環境変数の分類と管理

環境変数は以下のように論理的に分類されます：

1. **アプリケーション基本設定**
   - 基本URL、環境名、デバッグモードなど

2. **データベース接続設定**
   - PostgreSQL接続情報、プール設定など

3. **認証関連設定**
   - Auth.js設定、シークレットキー、JWTトークン設定

4. **OAuth設定**
   - 各プロバイダー（Google, GitHub, MS）のクライアントIDとシークレット

5. **Supabase設定**
   - URL、API Key、サービスロールキーなど

6. **ストレージ設定**
   - Vercel Blob、Supabase Storageの設定

7. **AIサービス設定**
   - OpenAI API Key、モデル設定、トークン制限など

8. **メール送信設定**
   - SMTPサーバー、認証情報、送信者アドレスなど

### 環境変数定義と検証

環境変数の定義と検証の具体例については、[コード例集](/docs/restructuring/code_examples/02_architecture_design_examples.md#環境変数定義)を参照してください。

### 環境変数の使用パターン

1. **直接インポート**
```typescript
   import { env } from '@/config/env';
   
   function uploadFile() {
     // 型安全に環境変数を使用
     const storageUrl = env.STORAGE_URL;
  // ...
   }
   ```

2. **サービス設定での使用**
```typescript
   import { env } from '@/config/env';
   
   export const databaseConfig = {
     url: env.DATABASE_URL,
     maxConnections: env.DATABASE_POOL_MAX,
     ssl: env.NODE_ENV === 'production',
   };
   ```

### 環境ごとの設定管理

- **開発環境**: `.env.development.local`（バージョン管理外）
- **テスト環境**: `.env.test`（CI/CDパイプラインで使用）
- **本番環境**: VercelやSupabaseのシークレット管理画面で設定

## リトライメカニズムと回復戦略

外部依存サービス（OpenAI API、データベース、ストレージなど）との通信における一時的な障害に対処するための堅牢なリトライメカニズムを実装します。

### リトライ戦略の原則

1. **エラー分類と選択的リトライ**
   - 一時的なエラー（ネットワーク障害、サーバー過負荷）：リトライ対象
   - 永続的なエラー（認証エラー、無効なパラメータ）：即時失敗

2. **指数バックオフと揺らぎ**
   - リトライ間隔を徐々に増加（例：500ms → 1000ms → 2000ms）
   - 揺らぎを追加（±10%）してサンダーハードプロブレムを回避

3. **最大リトライ回数の制限**
   - リソースの種類に応じた適切な最大リトライ回数
   - 重要度の高い操作は回数を増加

4. **サーキットブレーカーパターン**
   - 一定数の連続失敗で一定時間サービス呼び出しを停止
   - システム全体の安定性を確保

### リトライメカニズム実装

リトライメカニズムの実装例については、[コード例集](/docs/restructuring/code_examples/02_architecture_design_examples.md#リトライメカニズム)を参照してください。

### データベース操作のリトライロジック

データベース操作に対するリトライ実装例については、[コード例集](/docs/restructuring/code_examples/02_architecture_design_examples.md#リトライメカニズム)を参照してください。

## モニタリングとログ管理

効果的なシステム監視とログ管理により、問題の早期発見とパフォーマンス最適化を実現します。

### ログレベルと種類

- **ERROR**: システムの動作を妨げる重大な問題
- **WARN**: 潜在的な問題や異常な動作
- **INFO**: 重要なシステムイベント（起動、シャットダウン、大きな状態変化）
- **DEBUG**: トラブルシューティングに役立つ詳細情報（開発環境のみ）
- **TRACE**: 非常に詳細な実行フロー情報（特定の問題調査時のみ）

### 構造化ログの実装

```typescript
// ログエントリの基本構造
interface LogEntry {
  timestamp: string;      // ISO8601形式のタイムスタンプ
  level: LogLevel;        // ログレベル（ERROR, WARN, INFO, DEBUG, TRACE）
  message: string;        // 人間可読なメッセージ
  context?: Record<string, any>; // 追加コンテキスト情報
  userId?: string;        // 関連するユーザーID（該当する場合）
  requestId?: string;     // リクエスト識別子（分散トレーシング用）
  component: string;      // ログを出力したコンポーネント
  stackTrace?: string;    // エラーの場合のスタックトレース
}
```

### モニタリング対象

1. **アプリケーションメトリクス**
   - リクエスト数、レスポンス時間、エラー率
   - ルートごとのパフォーマンス統計
   - メモリ使用量、CPU使用率、イベントループ遅延

2. **ユーザー体験メトリクス**
   - First Contentful Paint (FCP)
   - Largest Contentful Paint (LCP)
   - First Input Delay (FID)
   - Cumulative Layout Shift (CLS)
   - クライアントサイドエラー率

3. **ビジネスメトリクス**
   - アクティブユーザー数
   - 機能別使用統計
   - コンバージョン指標
   - AI生成リクエスト数と成功率

### ログ収集と分析基盤

- **開発環境**: コンソール + ローカルログファイル
- **本番環境**: Vercel Logs + カスタム統合（DatadogまたはNew Relic）
- **ログの保持期間**: 30日（運用データ）、90日（集計・分析データ）

## パフォーマンス最適化戦略

アプリケーションのパフォーマンスと応答性を確保するための包括的な最適化戦略を実装します。

### クライアントサイド最適化

1. **コンポーネント分割と遅延ロード**
   - ルートベースのコード分割
   - 重いコンポーネントの遅延ロード（React.lazy/Suspense）
   - 下位ルート優先のコンポーネント構造

2. **レンダリング最適化**
   - 効率的なステート管理（不要な再レンダリングの回避）
   - メモ化（React.memo, useMemo, useCallback）
   - ビルトインコンポーネントの最適化（shadcn/ui）

3. **アセット最適化**
   - 画像の最適化（next/image、サイズ適合、WebP/AVIF形式）
   - フォントの最適化（サブセット化、preload）
   - CSSの最適化（Tailwind JIT、未使用スタイルの削除）

### サーバーサイド最適化

1. **レンダリング戦略**
   - Static Site Generation (SSG): 変更頻度の低いページ
   - Incremental Static Regeneration (ISR): 準静的コンテンツ
   - Server-Side Rendering (SSR): 動的だが頻繁に変わらないデータ
   - Client-Side Rendering (CSR): 高度にパーソナライズされたコンテンツ

2. **キャッシュ戦略**
   - React Server Components (RSC) キャッシュ
   - データキャッシュ（Vercel KV）
   - API応答キャッシュ（SWR, React Query）
   - ブラウザキャッシュ（Cache-Control, ETag）

3. **データベースパフォーマンス**
   - クエリ最適化（インデックス、効率的な結合）
   - 接続プーリング
   - 必要なフィールドのみの取得
   - N+1問題の回避

### AIレスポンス最適化

1. **ストリーミングレスポンス**
   - Server-Sent Events (SSE) を使用したAIレスポンスのストリーミング
   - プログレッシブUI更新

2. **プロンプト最適化**
   - コンテキスト圧縮技術
   - 重要情報の優先順位付け
   - プロンプトテンプレートの継続的改善

3. **クライアントサイドキャッシング**
   - 類似クエリの結果キャッシュ
   - 部分的な応答のキャッシュと再利用

### バンドルサイズ最適化

```bash
# バンドル分析ツールの実行
npm run analyze-bundle

# 出力例（抜粋）
Page                                     Size     First Load JS
┌ ● /                                    5.2 kB        85.7 kB
├   /_app                                0 B            80.5 kB
├ ○ /404                                 194 B          80.7 kB
├ ○ /api/auth/[...nextauth]              0 B            80.5 kB
├ λ /api/ai/chat                         0 B            80.5 kB
└ λ /projects/[id]                       29.2 kB       110 kB
+ First Load JS shared by all            80.5 kB
  ├ chunks/framework-8883d1e9be70c3da.js 45.7 kB
  ├ chunks/main-f65e66e62fc5ca53.js      30.7 kB
  ├ chunks/pages/_app-b555d5e1eab47959.js 296 B
  └ chunks/webpack-69bfa6990bb9e155.js   769 B
```

### パフォーマンスメトリクス

1. **フロントエンド**
   - Core Web Vitals: LCP < 2.5s, FID < 100ms, CLS < 0.1
   - Time to Interactive (TTI) < 3.8s
   - Total Blocking Time (TBT) < 200ms

2. **バックエンド**
   - API応答時間: P95 < 500ms, P99 < 1000ms
   - DB操作時間: P95 < 200ms, P99 < 500ms
   - AI応答初速: TTFB < 300ms

## 継続的インテグレーションとデプロイ

アプリケーションの開発からデプロイまでの一貫したパイプラインを構築し、品質とスピードを両立させます。

### CI/CDパイプライン

1. **コード品質チェック**
   - ESLint: コーディング標準の遵守
   - TypeScript: 型チェック
   - Prettier: コードフォーマット
   - テスト: ユニットテスト、統合テスト
   - カバレッジレポート: テストカバレッジ分析

2. **ビルドプロセス**
   - 依存関係のインストール
   - アプリケーションビルド
   - 静的アセットの最適化

3. **デプロイワークフロー**
   - プレビュー環境: Pull Request毎
   - ステージング環境: main/masterブランチへのマージ後
   - 本番環境: タグリリース後

### データベースマイグレーション管理

Drizzle Kitを使用して、データベースのバージョン管理とマイグレーションを安全に実行します。

1. **マイグレーションフロー**
   - スキーマ定義更新（Drizzle Schema）
   - マイグレーションファイル生成 (`drizzle-kit generate`)
   - マイグレーションの実行 (`drizzle-orm migrate`)

2. **環境ごとのマイグレーション戦略**
   - 開発: 自動実行（アプリ起動時）
   - テスト: 環境再構築時
   - ステージング: CI/CDパイプラインの一部として
   - 本番: 手動承認後に実行

### 環境分離とフィーチャーフラグ

1. **環境管理**
   - 開発（Development）: ローカル開発用
   - テスト（Testing）: 自動テスト実行用
   - プレビュー（Preview）: PR検証用
   - ステージング（Staging）: リリース前確認用
   - 本番（Production）: エンドユーザー向け

2. **フィーチャーフラグ**
   - 環境変数ベースのフラグ制御
   - ユーザーロールベースのアクセス制御
   - 段階的ロールアウト機能

## まとめと移行戦略

本アーキテクチャ設計は、AiStartの長期的な成長と進化を支える基盤となります。各コンポーネントは独立して開発・テスト可能であり、将来的なマイクロサービスへの移行も視野に入れています。

### アーキテクチャの主要メリット

1. **高い保守性と拡張性**
   - 関心の分離による変更影響範囲の最小化
   - ドメイン中心設計による業務変化への適応
   - 明確なレイヤー構造による理解しやすさ

2. **テスト容易性の向上**
   - 純粋なドメインロジックの単体テスト
   - モックを使用したインフラ依存のテスト
   - エンドツーエンドテストによる総合検証

3. **段階的な進化の実現**
   - 初期はモノリシックで迅速に開発
   - 成長に合わせた段階的なマイクロサービス化
   - ドメイン境界に沿った分割容易性

### 次のステップ

1. **プロトタイプ開発**
   - 本アーキテクチャに基づく初期プロトタイプの開発
   - 主要フローの検証と改善
   - パフォーマンス特性の評価

2. **開発ガイドライン整備**
   - コーディング規約の詳細化
   - 実装パターンの標準化
   - ナレッジベースの構築

3. **チーム体制の整備**
   - 機能領域に応じたチーム構成
   - 共通基盤のガバナンス体制
   - トレーニングと知識共有

このアーキテクチャ設計を出発点として、実装フェーズでの学びを反映しながら継続的に進化させていきます。

### 5.2. クライアントサイドアーキテクチャ

クライアントサイドはNext.js (App Router) を基盤とし、React Server Components (RSC) と Client Components を活用します。

- **フレームワーク**: Next.js (App Router)
- **UI ライブラリ**: Shadcn/UI + Tailwind CSS
- **状態管理**: TanStack Query (React Query) + Jotai/Zustand/Context API
- **コンポーネント開発**: **Storybook** を導入し、UIコンポーネントの分離開発、テスト、ドキュメンテーションを効率化します。

**主要な関心事:**

1.  **UI Components (`src/components/ui`, `src/components/shared`)**: 再利用可能な基本的なUI要素（ボタン、入力フィールドなど）と、複数の箇所で利用される共有コンポーネント。
2.  **Feature Components (`src/features`)**: 特定の機能に関連するコンポーネント群。ドメインロジックを含む場合がある。
3.  **Layouts (`src/components/layouts`)**: ページの全体的な構造を定義するコンポーネント。
4.  **Pages/Routes (`src/app`)**: Next.js の App Router に基づくルーティングとページコンポーネント。
5.  **State Management (`src/store`, `src/hooks`)**: グローバルな状態管理、カスタムフック、API データフェッチとキャッシュ管理。
6.  **Utilities (`src/lib`, `src/utils`)**: アプリケーション全体で使用されるヘルパー関数や定数。

**コンポーネント設計原則:**

-   **Presentational and Container Components**: 必要に応じて、表示ロジックとビジネスロジックを分離します。
-   **Atomic Design**: コンポーネントを Atoms, Molecules, Organisms, Templates, Pages の粒度で設計し、再利用性と保守性を高めます。
-   **Props Drilling の回避**: Context API, Zustand, Jotai などを適切に利用して、不要な Props のバケツリレーを避けます。
-   **パフォーマンス**: RSC と Client Components を適切に使い分け、不要な再レンダリングを最小限に抑えます。

**Storybook の活用:**

Storybook は、UIコンポーネントの開発プロセスにおいて中心的な役割を果たします。

-   **分離開発**: 各コンポーネントをアプリケーション全体から切り離して開発・テストできるため、開発サイクルが高速化します。
-   **インタラクティブなカタログ**: 開発者やデザイナーが利用可能なコンポーネントとそのバリエーションを簡単に確認できます。
-   **ビジュアルテスト**: Chromatic などのツールと連携し、コンポーネントの視覚的なリグレッションテストを自動化します。
-   **ドキュメンテーション**: コンポーネントの使用方法や Props に関する「生きたドキュメント」として機能します。