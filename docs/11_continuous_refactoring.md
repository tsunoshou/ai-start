# 継続的リファクタリング計画

最終更新日: 2025-04-03

## 目的

このドキュメントは、AiStartプロジェクトにおける継続的なリファクタリングの戦略、プロセス、および文化を定義します。目的は以下の通りです。

-   **コード品質の維持・向上**: 時間の経過と共にコードが劣化するのを防ぎ、理解しやすく、変更しやすい状態を維持します。
-   **技術的負債の管理・返済**: 意図的または非意図的に発生した技術的負債を特定し、計画的に解消します。
-   **変化への適応力向上**: 新しい要件や技術の変化に迅速かつ安全に対応できる、柔軟なコードベースを維持します。
-   **開発者体験の向上**: 読みやすく、テストしやすく、デバッグしやすいコードにより、開発者の生産性と満足度を高めます。
-   **ドキュメントとの整合性維持**: コードの変更に合わせて、関連する設計ドキュメント ([01_requirements_definition.md](/docs/restructuring/01_requirements_definition.md) から [10_deployment_implementation.md](/docs/restructuring/10_deployment_implementation.md) まで) との整合性を保ちます。

## 対象範囲

継続的リファクタリングの対象は、コードベース全体と関連する成果物です。

-   **アプリケーションコード**: ドメインロジック、アプリケーションサービス、UIコンポーネント (React Server Components / Client Components)、APIルートハンドラー、サーバーアクションなど。
-   **インフラストラクチャコード**: リポジトリ実装、外部サービス連携クライアント、データベーススキーマ定義 (Drizzle)、マイグレーションスクリプトなど。
-   **テストコード**: ユニットテスト、統合テスト、E2Eテストコード ([09_testing_implementation.md](/docs/restructuring/09_testing_implementation.md) 参照)。
-   **CI/CD パイプライン**: GitHub Actions ワークフロー ([10_deployment_implementation.md](/docs/restructuring/10_deployment_implementation.md) 参照)。
-   **ドキュメンテーション**: このディレクトリ (`docs/restructuring/`) 内の全ての設計・実装ドキュメント。

## リファクタリングのトリガー

以下の状況をリファクタリングを開始するきっかけ（トリガー）とします。

-   **機能追加・変更時 (ボーイスカウト・ルール)**: 新しい機能を追加したり、既存の機能を変更したりする際に、関連するコードを以前よりもきれいな状態にします。「来た時よりも美しく」。
-   **コードレビュー**: プルリクエストのレビュープロセスで、改善の余地があるコード（複雑なロジック、重複コード、命名の不一致、設計原則違反など）が指摘された場合。
-   **バグ修正時**: バグの原因がコードの分かりにくさや複雑さに起因する場合、修正と同時にリファクタリングを行います。
-   **技術的負債の発見**: コードの理解や変更が困難な箇所、パフォーマンス上のボトルネック、テストが書きにくい箇所などを発見した場合。
-   **技術トレンドの変化**: 新しい言語機能、ライブラリのベストプラクティス、アーキテクチャパターンの登場などにより、既存コードの改善が見込める場合。
-   **定期的な見直し**: 特定のモジュールや機能について、定期的に（例: 四半期ごと）コードの健全性を評価し、計画的なリファクタリングを実施します。
-   **ドキュメントとの乖離**: コードの実装が設計ドキュメントと乖離していることが判明した場合。

## リファクタリングプロセス

リファクタリングは、以下のステップで慎重に進めます。

1.  **問題の特定と理解**: リファクタリングが必要な箇所とその理由（コードの臭い、技術的負債、パフォーマンス問題など）を明確に特定し、現在のコードの動作を完全に理解します。
2.  **目標設定**: リファクタリングによって何を達成したいのか、具体的な改善目標を設定します（例: 可読性の向上、複雑度の低減、テスト容易性の向上、パフォーマンス改善）。
3.  **テストの確保**: リファクタリング対象のコードに対するテスト ([09_testing_implementation.md](/docs/restructuring/09_testing_implementation.md) 参照) が存在し、パスすることを確認します。テストがない場合は、リファクタリング前にテストを作成します。これは、リファクタリングによって既存の動作が破壊されていないことを保証するために不可欠です。
4.  **計画**: 小さなステップに分割してリファクタリングを進める計画を立てます。一度に大きな変更を加えるのではなく、段階的に改善します。
5.  **実装 (小さなステップで)**: 計画に基づき、コードを少しずつ変更します。各ステップの後で、テストを実行し、動作が変わっていないことを確認します。
    -   IDE のリファクタリング支援機能を積極的に活用します。
    -   実装ルール ([04_implementation_rules.md](/docs/restructuring/04_implementation_rules.md)) やアーキテクチャ設計 ([02_architecture_design.md](/docs/restructuring/02_architecture_design.md)) に準拠するように修正します。
6.  **テスト実行**: 全てのステップが完了したら、再度全ての関連テストを実行し、リファクタリングが既存の機能に影響を与えていないことを最終確認します。
7.  **ドキュメント更新**: コードの変更に伴い、関連するドキュメント ([01_requirements_definition.md](/docs/restructuring/01_requirements_definition.md) から [10_deployment_implementation.md](/docs/restructuring/10_deployment_implementation.md) まで) も更新し、整合性を保ちます。特にアーキテクチャや実装ルールに関する変更があった場合は重要です。
8.  **レビュー**: リファクタリングの内容をプルリクエストでレビュー依頼します。レビューでは、コードの改善度、テストの妥当性、ドキュメント更新の適切性などを確認します。
9.  **マージ**: レビューで承認されたら、変更をマージします。

## 指標と計測

リファクタリングの効果とコードベースの健全性を測るために、以下の指標を参考にします。

-   **コード複雑度 (Cyclomatic Complexity)**: 関数やメソッドの複雑度を計測し、高い箇所をリファクタリング対象の候補とします (IDE プラグインや静的解析ツールで計測)。
-   **コードカバレッジ**: テストコードがソースコードのどれだけの割合をカバーしているかを示します ([09_testing_implementation.md](/docs/restructuring/09_testing_implementation.md) で目標値を定義)。リファクタリングによってカバレッジが低下しないように注意し、向上を目指します。
-   **静的解析ツールの警告数**: ESLint などの静的解析ツールが出力する警告数を監視し、削減を目指します。
-   **パフォーマンス指標**: レスポンスタイム、メモリ使用量などのパフォーマンス指標 ([10_deployment_implementation.md](/docs/restructuring/10_deployment_implementation.md) 参照) を計測し、リファクタリングによる改善効果を確認します。
-   **バグ発生率**: 特定モジュールにおけるバグの発生頻度を追跡し、リファクタリングによる品質向上効果を確認します。
-   **開発者の主観評価**: コードの読みやすさ、変更しやすさなどについて、定期的に開発者アンケートやヒアリングを行い、主観的な改善度を評価します。

これらの指標は絶対的なものではなく、あくまで傾向を把握するための参考情報として活用します。

## 優先順位付け

リソースは有限であるため、すべてのリファクタリングを同時に行うことはできません。以下の観点を考慮して優先順位を決定します。

-   **影響範囲**: リファクタリング対象がシステム全体に与える影響の大きさ。コアとなるドメインロジックや頻繁に変更される箇所は優先度が高くなります。
-   **緊急度**: パフォーマンス上の深刻な問題、セキュリティ脆弱性、頻繁なバグの原因となっている箇所は緊急度が高くなります。
-   **ROI (投資対効果)**: リファクタリングに要するコスト（時間、工数）と、それによって得られるメリット（開発効率向上、バグ削減、パフォーマンス改善など）を比較検討します。
-   **開発チームの状況**: チームのスキルセット、現在の開発タスクとの兼ね合いを考慮します。

優先順位付けは、プロダクトオーナーや開発チームとの協議を通じて決定します。

## ツール

リファクタリングを効率的かつ安全に進めるために、以下のツールを活用します。

-   **IDE (Visual Studio Codeなど)**: 名前の変更、メソッドの抽出、変数のインライン化など、豊富なリファクタリング支援機能を提供します。
-   **静的解析ツール (ESLint)**: コードの潜在的な問題やスタイル違反を検出し、リファクタリングの必要箇所を示唆します。
-   **型チェック (TypeScript)**: 静的な型チェックにより、リファクタリング中の型関連のエラーを早期に発見できます。
-   **テストフレームワーク (Vitest, Playwright)**: リファクタリング前後でコードの動作が変わっていないことを保証するための必須ツールです。カバレッジ計測機能も活用します。
-   **バージョン管理システム (Git)**: リファクタリングの変更履歴を管理し、問題発生時に以前の状態に戻すことを可能にします。

## 文化の醸成

継続的なリファクタリングを成功させるためには、チーム全体でその重要性を理解し、実践する文化を醸成することが不可欠です。

-   **リファクタリングの時間を確保**: 新機能開発だけでなく、リファクタリングのための時間を計画的に確保します（例: スプリント計画の一部、専用のリファクタリングデー）。
-   **心理的安全性**: 既存のコードを改善することを推奨し、失敗を恐れずに挑戦できる雰囲気を作ります。
-   **知識共有**: リファクタリングのテクニック、設計パターン、コードの臭いなどに関する知識をチーム内で共有します（ペアプログラミング、モブプログラミング、勉強会など）。
-   **オーナーシップ**: チームメンバー全員がコードベース全体の品質に対する責任感を持ち、積極的に改善に取り組みます。
-   **ドキュメント更新の習慣化**: リファクタリングとドキュメント更新はセットで行うことを徹底します。

## ドキュメントとの連携

コードのリファクタリングは、必ず関連するドキュメントの更新とセットで行います。

-   アーキテクチャや設計に関する大きな変更を行った場合は、`02_architecture_design.md` や関連する実装ドキュメント (`07`, `08` など) を更新します。
-   実装ルールや命名規則を変更した場合は、`04_implementation_rules.md` を更新します。
-   API の仕様変更を伴う場合は、API ドキュメント (Swagger/OpenAPI など、または `07_server_implementation.md` 内の記述) を更新します。
-   テスト戦略や方針に変更があった場合は、`09_testing_implementation.md` を更新します。
-   デプロイプロセスやインフラ構成に変更があった場合は、`10_deployment_implementation.md` を更新します。

ドキュメントとコードの整合性を常に保つことで、プロジェクト全体の理解度を高め、将来の開発者が迷うことなく作業を進められるようにします。 