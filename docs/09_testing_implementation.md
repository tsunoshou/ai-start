# テストの実装

最終更新日: 2024-07-27

このドキュメントは、AiStartプロジェクトにおけるテスト戦略、手法、ツール、およびプロセスを定義します。[01_requirements_definition.md](/docs/restructuring/01_requirements_definition.md) で定義された品質要件と [02_architecture_design.md](/docs/restructuring/02_architecture_design.md) で定義されたアーキテクチャに基づき、高品質で保守性の高いソフトウェア開発を目指します。

## テスト戦略

### テストピラミッドとバランス

ソフトウェアテストの自動化においては、テストピラミッドの考え方を基本とします。

- **ユニットテスト (Unit Tests)**: 最も多くのテストを配置します。関数、メソッド、ドメインオブジェクト、純粋なUIコンポーネントなど、最小単位のロジックを検証します。高速に実行でき、問題箇所を特定しやすいのが特徴です。
- **統合テスト (Integration Tests)**: 複数のユニット（モジュール、コンポーネント、サービス）が連携して正しく機能するかを検証します。APIエンドポイント、データベースとの連携、フロントエンドの状態管理とコンポーネントの連携などが対象です。ユニットテストより数は少なくなります。
- **エンドツーエンドテスト (E2E Tests)**: ユーザーの視点から、実際のブラウザや環境を使ってアプリケーション全体の主要なワークフローを検証します。最も数は少なくなりますが、システム全体の動作保証に不可欠です。

このバランスにより、効率的かつ網羅的なテストを実現します。

### テスト優先度

すべてのコードを均等にテストするのではなく、以下の領域に重点を置いてテストを実施します。

1.  **ドメインロジック**: ビジネスルールの中核をなすドメインエンティティ、値オブジェクト、ドメインサービスのロジック。
2.  **APIエンドポイント**: クライアントとの契約となるAPIの入力バリデーション、処理ロジック、出力形式、認証・認可。
3.  **認証・認可**: ログイン、セッション管理、ロールベースアクセス制御（RBAC）、行レベルセキュリティ（RLS）関連のロジック。
4.  **クリティカルなUIパス**: ユーザー登録、主要機能の操作フロー、決済処理など、ビジネス上重要なユーザー操作。
5.  **外部サービス連携**: 外部API（AIサービス、決済サービスなど）との連携部分のインターフェースとエラーハンドリング。

### テスト駆動開発（TDD）の適用

TDD（テスト駆動開発）のプラクティスを**推奨**します。特にドメインロジックや複雑なアルゴリズムの実装においては、テストを先に書くことで設計の改善や仕様の明確化につながります。ただし、プロジェクト全体で厳格にTDDを強制するものではなく、状況に応じて適用します。

## ユニットテスト

### テストフレームワーク

- **Vitest**: 主要なユニットテストおよび統合テストフレームワークとして採用します。
  - **理由**: Viteベースのプロジェクト（Next.js含む）との親和性が高く、高速な実行速度、Jest互換のAPI、TypeScriptサポート、設定の容易さ。

### テスト範囲

- ドメインエンティティ、値オブジェクト (VO) のメソッドと不変性
- ドメインサービス、アプリケーションサービス（Use Case）内の純粋なロジック
- ユーティリティ関数 ([06_utility_functions.md](/docs/restructuring/06_utility_functions.md) 参照)
- Reactコンポーネントのうち、状態を持たない純粋なプレゼンテーショナルコンポーネント（UIの描画結果を検証, RTL利用）
- Reactカスタムフックのロジック（`@testing-library/react-hooks` またはRTLの `renderHook` 利用）
- サーバーアクション、API Route Handlers内の分離可能なロジック部分

### テストパターン

- **Arrange-Act-Assert (AAA)** パターンを基本とします。
- 境界値分析、同値分割などのテストケース設計技法を適用します。
- 依存関係はVitestのモック機能 (`vi.mock`, `vi.fn`, `vi.spyOn`) を使用して分離します。

## 統合テスト

### テスト対象

- **APIエンドポイント**: リクエスト受信からレスポンス返却までの一連の流れ（ミドルウェア含む）。`supertest` やVitestのインテグレーションテスト機能を利用。
- **アプリケーションサービス (Use Case)**: 依存するリポジトリや外部サービス（モック化）を含めたユースケース全体の動作検証。
- **リポジトリ実装**: 実際のテストデータベース（コンテナ化推奨）に接続し、CRUD操作やRLSが正しく機能するか検証。
- **フロントエンドコンポーネント連携**: 複数のReactコンポーネントが状態管理ライブラリ（Context, Jotai, TanStack Query）やルーター（モック）と連携して意図通りに動作するかを検証（RTL利用）。
- **サーバーコンポーネント(RSC)とクライアントコンポーネント(CC)の連携**: 必要に応じて、データの受け渡しや状態更新が正しく行われるか検証。

## E2Eテスト

### E2Eテストツール

- **Playwright**: 主要なE2Eテストツールとして採用します。
  - **理由**: [08_client_implementation.md](/docs/restructuring/08_client_implementation.md) でも言及。高速かつ安定した動作、複数ブラウザ（Chromium, Firefox, WebKit）対応、強力なセレクタエンジン、自動待機機能、テストコード生成機能、TypeScriptサポート。

### テストシナリオ

- ユーザー登録、ログイン/ログアウト
- プロジェクトの新規作成、編集、削除
- プログラムのステップ実行、AIとの対話
- サブスクリプションプランの選択、変更
- 管理者によるユーザー管理、コンテンツ管理などの主要機能
- 主要な画面遷移と表示内容の確認

### CI/CDとの連携

- GitHub ActionsなどのCI/CDパイプラインに組み込み、定期的に（例: mainブランチへのマージ前、デプロイ前）自動実行します。

## テストカバレッジ

### カバレッジ目標

- [01_requirements_definition.md](/docs/restructuring/01_requirements_definition.md) の保守性要件に基づき、テストコードによる**行カバレッジ全体で80%以上**を目指します。

### カバレッジ計測

- **Vitest** の組み込みカバレッジ機能 (`@vitest/coverage-v8`) を使用して計測します。
- CIプロセスでカバレッジレポートを生成し、開発者が確認できるようにします（例: Codecov連携）。

### 重点箇所

- ドメインロジック: 90%以上
- APIエンドポイントの主要ロジック: 85%以上
- 認証・認可関連: 90%以上
- 上記以外の箇所も、重要度に応じて適切なカバレッジを確保します。

## モック/スタブ戦略

### モックライブラリ

- **Vitest** の組み込みモック機能 (`vi.mock`, `vi.fn`, `vi.spyOn`) を主に使用します。これにより、外部依存性を排除し、テスト対象のユニットを分離します。

### 外部サービスのモック

- 外部API（AIサービス、決済サービスなど）やSDKとの連携部分は、インターフェースを定義し、テスト時にはそのインターフェースのモック実装を提供します。
- フロントエンドでのAPIリクエストのモックには **Mock Service Worker (MSW)** の利用を検討します。ブラウザやNode.jsレベルでネットワークリクエストをインターセプトし、モックレスポンスを返すことができます。

### データベースのモック

- **ユニットテスト**: リポジトリインターフェース ([04_implementation_rules.md](/docs/restructuring/04_implementation_rules.md) 参照) のインメモリ実装やVitestモックを使用します。
- **統合テスト**:
  - **テストコンテナ**: Dockerコンテナ（例: `testcontainers-node`）を使用して、テストごとに独立したPostgreSQLデータベースインスタンスを起動・破棄することを推奨します。これにより、実際のDB環境に近い状態でテストを実行できます。
  - **テスト用スキーマ**: [06_utility_functions.md](/docs/restructuring/06_utility_functions.md) の `setupTestDatabase` のようなヘルパー関数を使用し、テスト実行ごとに専用のDBスキーマを作成・削除します。

## テストデータ管理

### テストデータ生成

- **Faker.js**: リアルなテストデータを生成するために活用します。
- **ファクトリ関数**: テスト対象のエンティティやオブジェクトを生成するための専用関数（例: `createUser`, `createProject`）を作成し、テストコードの可読性と再利用性を高めます。

### フィクスチャ

- 繰り返し使用する固定的なテストデータは、JSONファイルやTypeScriptのオブジェクト/配列として管理します (`tests/fixtures/` ディレクトリなど)。

### テスト環境データ

- 各テストケース（またはテストスイート）は、他のテストから独立して実行されるべきです。
- `beforeEach`, `afterEach` (Vitest) などを使用して、テスト実行前にテストデータのセットアップ（DBへの投入など）と、実行後にクリーンアップ（DBのロールバックや削除）を行います。

## パフォーマンステスト

### 負荷テストツール

- **k6**: モダンな負荷テストツールとして採用を検討します。JavaScriptでテストシナリオを記述でき、開発者にとって親和性が高いです。
- その他候補: `Locust`, `JMeter` なども要件に応じて検討します。

### テストシナリオ

- [01_requirements_definition.md](/docs/restructuring/01_requirements_definition.md) のパフォーマンス要件（レスポンスタイム、スループット、同時接続数）に基づき、主要なAPIエンドポイントやユーザーシナリオに対する負荷テストを実施します。

### ベンチマーク

- 定期的に（例: リリース前）パフォーマンステストを実施し、ベースラインとなる性能指標（ベンチマーク）を記録します。性能劣化が検知された場合は原因を調査し、対策を講じます。

## セキュリティテスト

### セキュリティテストツール/手法

- **依存関係スキャン**: `npm audit` や `Snyk` を使用して、利用しているライブラリの既知の脆弱性をCI/CDプロセスで継続的にチェックします。
- **静的解析 (SAST)**: `eslint-plugin-security` などのリンタープラグインや、専用のSASTツールを導入し、コードレベルでの潜在的なセキュリティ問題を早期に発見します。
- **動的解析 (DAST)**: 必要に応じて、ステージング環境などで `OWASP ZAP` などのツールを使用し、実行中のアプリケーションに対する脆弱性スキャンを実施します。
- **手動レビュー**: 認証・認可、入力検証、機密データ処理など、セキュリティ上重要な箇所については、コードレビュー時に特に注意深く確認します。

### 脆弱性スキャン頻度

- 依存関係スキャンと静的解析は、CI/CDパイプラインの一部として、コードのプッシュごとに実行します。
- 動的解析は、リリース前や定期的に（例: 四半期ごと）実施することを検討します。

## CIとの連携

### CI設定

- **GitHub Actions**: 主要なCI/CDプラットフォームとして使用します。ワークフローファイル (`.github/workflows/`) でテストプロセスを定義します。

### 自動テスト実行

- コードがリポジトリにプッシュされた際 (`push` イベント) や、プルリクエストが作成・更新された際 (`pull_request` イベント) に、ユニットテスト、統合テスト、リンター/フォーマッターチェックを自動実行します。
- 特定のブランチ（例: `main`, `staging`）へのマージ時やデプロイ前に、E2Eテストも自動実行します。

### テスト結果の可視化

- GitHub Actionsの実行結果サマリーでテストの成否を確認できます。
- テストカバレッジレポートは、Codecovなどの外部サービスと連携するか、GitHub Actionsのアーティファクトとして保存し、開発者が容易にアクセスできるようにします。

## テスト文化の醸成

### テストレビュー

- プルリクエストのレビュープロセスにおいて、実装コードだけでなく、テストコードもレビューの対象とします。テストの妥当性、網羅性、可読性を評価します。

### テスト品質向上施策

- 定期的にテストコードのリファクタリングを行います。
- テスト失敗時のデバッグを容易にするためのログ出力や情報収集を工夫します。
- 新しいテスト手法やツールの導入を検討し、継続的にテストプロセスを改善します。

### チーム内テスト教育

- テストの重要性や基本的な書き方について、ドキュメントや勉強会を通じてチームメンバーの理解を深めます。
- 効果的なテスト戦略や設計パターンに関する知識共有を促進します。


**注意**: 具体的なテストコードの書き方や例については、`code_examples/09_testing_implementation_examples.md` を参照してください。 