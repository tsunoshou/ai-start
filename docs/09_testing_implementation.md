# テストの実装

最終更新日: 2025-04-10

このドキュメントは、AiStartプロジェクトにおけるテスト戦略、手法、ツール、およびプロセスを定義します。[01_requirements_definition.md](/docs/restructuring/01_requirements_definition.md) で定義された品質要件と [02_architecture_design.md](/docs/restructuring/02_architecture_design.md) で定義されたアーキテクチャに基づき、高品質で保守性の高いソフトウェア開発を目指します。

## テストファイルの配置場所

テストコードの場所は、プロジェクトの一貫性とメンテナンス性に影響します。以下の配置方針を**採用**します。

### ユニットテスト/統合テスト (Vitest, React Testing Library)

- **原則**: テスト対象となるソースファイルと同じディレクトリ内に `__tests__` サブディレクトリを作成し、その中にテストファイルを配置します。
- **ファイル名**: テストファイルのサフィックスは `.test.ts` (または `.test.tsx`) を使用します。

- **例 (コンポーネントテスト)**:
  ```
  presentation/
  └── components/
      └── common/
          └── Button/
              ├── Button.tsx
              └── __tests__/
                  └── Button.test.tsx
  ```
- **例 (その他 - ドメイン、アプリケーション、インフラ層のテスト)**:
  ```
  domain/
  └── models/
      └── user/
          ├── user.entity.ts
          └── __tests__/
              └── user.entity.test.ts

  application/
  └── usecases/
      ├── auth/
      │   ├── auth.usecase.ts
      │   └── __tests__/
      │       └── auth.usecase.test.ts
      └── project/
          └── ...

  infrastructure/
  └── database/
      └── repositories/
          ├── user.repository.ts
          └── __tests__/
              └── user.repository.integration.test.ts
  ```

### E2Eテスト (Playwright)

- **専用ディレクトリ方式**:
  - プロジェクトルート直下の `tests/e2e/` ディレクトリに、すべてのE2Eテストファイル (`.spec.ts`) を配置します。
  - **APIテストの構成**: APIエンドポイントのテストもこのディレクトリ内 (`tests/e2e/api/` など) に配置し、関連するリソース（例: ユーザー、プロジェクト）ごとに1つのスペックファイル (`users.spec.ts`, `projects.spec.ts` など) にまとめることを推奨します。これにより、セットアップ/ティアダウン処理の共通化やテストの管理が容易になります。
  - **理由**: E2Eテストは特定のファイルではなくユーザーシナリオ全体を対象とするため、ソースコードとは分離された専用の場所にまとめるのが適切です。

## テスト戦略

### テストピラミッドとバランス

ソフトウェアテストの自動化においては、テストピラミッドの考え方を基本とします。

- **ユニットテスト (Unit Tests)**: 最も多くのテストを配置します。関数、メソッド、ドメインオブジェクト、純粋なUIコンポーネントなど、最小単位のロジックを検証します。高速に実行でき、問題箇所を特定しやすいのが特徴です。
- **統合テスト (Integration Tests)**: 複数のユニット（モジュール、コンポーネント、サービス）が連携して正しく機能するかを検証します。APIエンドポイント、データベースとの連携、フロントエンドの状態管理とコンポーネントの連携などが対象です。ユニットテストより数は少なくなります。
- **エンドツーエンドテスト (E2E Tests)**: ユーザーの視点から、実際のブラウザや環境を使ってアプリケーション全体の主要なワークフローを検証します。最も数は少なくなりますが、システム全体の動作保証に不可欠です。

このバランスにより、効率的かつ網羅的なテストを実現します。

### テスト優先度

すべてのコードを均等にテストするのではなく、以下の領域に重点を置いてテストを実施します。

1.  **ドメインロジック**: ビジネスルールの中核をなすドメインエンティティ、値オブジェクト、ドメインサービスのロジック。
2.  **APIエンドポイント**: クライアントとの契約となるAPIの入力バリデーション、処理ロジック、出力形式、認証・認可。
3.  **認証・認可**: ログイン、セッション管理、ロールベースアクセス制御（RBAC）、行レベルセキュリティ（RLS）関連のロジック。
4.  **クリティカルなUIパス**: ユーザー登録、主要機能の操作フロー、決済処理など、ビジネス上重要なユーザー操作。
5.  **外部サービス連携**: 外部API（AIサービス、決済サービスなど）との連携部分のインターフェースとエラーハンドリング。

### テスト駆動開発（TDD）の適用

TDD（テスト駆動開発）のプラクティスを**推奨**します。特にドメインロジックや複雑なアルゴリズムの実装においては、テストを先に書くことで設計の改善や仕様の明確化につながります。ただし、プロジェクト全体で厳格にTDDを強制するものではなく、状況に応じて適用します。

## ユニットテスト

### テストフレームワーク

- **Vitest**: 主要なユニットテストおよび統合テストフレームワークとして採用します。
  - **理由**: Viteベースのプロジェクト（Next.js含む）との親和性が高く、高速な実行速度、Jest互換のAPI、TypeScriptサポート、設定の容易さ。

### テスト範囲

- ドメインエンティティ、値オブジェクト (VO) のメソッドと不変性
- ドメインサービス、アプリケーションサービス（Use Case）内の純粋なロジック
- ユーティリティ関数 ([06_utility_functions.md](/docs/restructuring/06_utility_functions.md) 参照)
- Reactコンポーネントのうち、状態を持たない純粋なプレゼンテーショナルコンポーネント（UIの描画結果を検証, RTL利用）
    - **Storybook との連携**: Storybook を活用し、コンポーネントを分離した環境でテストします。各ストーリーは、コンポーネントの特定の状態や Props の組み合わせを表すテストケースとして機能します。これにより、インタラクションやエッジケースの検証が容易になります。
- Reactカスタムフックのロジック（`@testing-library/react-hooks` またはRTLの `renderHook` 利用）
- サーバーアクション、API Route Handlers内の分離可能なロジック部分

### テストパターン

- **Arrange-Act-Assert (AAA)** パターンを基本とします。
- 境界値分析、同値分割などのテストケース設計技法を適用します。
- 依存関係はVitestのモック機能 (`vi.mock`, `vi.fn`, `vi.spyOn`) を使用して分離します。

## 統合テスト

### テスト対象

- **APIエンドポイント**: リクエスト受信からレスポンス返却までの一連の流れ（ミドルウェア含む）。`supertest` やVitestのインテグレーションテスト機能を利用。
- **アプリケーションサービス (Use Case)**: 依存するリポジトリや外部サービス（モック化）を含めたユースケース全体の動作検証。
- **リポジトリ実装**: 実際のテストデータベース（コンテナ化推奨）に接続し、CRUD操作やRLSが正しく機能するか検証。これには、正常系の操作だけでなく、**存在しないIDでの検索 (`findById` で `null` が返るなど) や、一意性制約違反などのエッジケースのテストも含まれます。**
    - **注意点**: データベース操作のタイミングによっては、期待する状態変化（例: `updatedAt` が `createdAt` より後になる）が保証されない場合があります。ミリ秒単位での比較が難しい場合や、操作が非常に高速な場合は、アサーションで `>` ではなく `>=` を使用するなど、柔軟な検証が必要です（例: `UserRepository` の `save` 操作直後の `updatedAt` 検証）。
    - **テストデータの準備**: テストに必要なデータは過不足なく準備し、テストロジックに関係のない変数（例: `createMultipleUsers` の結果を保持するだけの変数）は宣言しないようにします。
- **フロントエンドコンポーネント連携**: 複数のReactコンポーネントが状態管理ライブラリ（Context, Jotai, TanStack Query）やルーター（モック）と連携して意図通りに動作するかを検証（RTL利用）。
- **サーバーコンポーネント(RSC)とクライアントコンポーネント(CC)の連携**: 必要に応じて、データの受け渡しや状態更新が正しく行われるか検証。

## E2Eテスト

### E2Eテストツール

- **Playwright**: 主要なE2Eテストツールとして採用します。
  - **理由**: [08_client_implementation.md](/docs/restructuring/08_client_implementation.md) でも言及。高速かつ安定した動作、複数ブラウザ（Chromium, Firefox, WebKit）対応、強力なセレクタエンジン、自動待機機能、テストコード生成機能、TypeScriptサポート。

### テストシナリオ

- ユーザー登録、ログイン/ログアウト
- プロジェクトの新規作成、編集、削除
- プログラムのステップ実行、AIとの対話
- サブスクリプションプランの選択、変更
- 管理者によるユーザー管理、コンテンツ管理などの主要機能
- 主要な画面遷移と表示内容の確認

### CI/CDとの連携

- GitHub ActionsなどのCI/CDパイプラインに組み込み、定期的に（例: mainブランチへのマージ前、デプロイ前）自動実行します。

## テストカバレッジ

### カバレッジ目標

- [01_requirements_definition.md](/docs/restructuring/01_requirements_definition.md) の保守性要件に基づき、テストコードによる**行カバレッジ全体で80%以上**を目指します。

### カバレッジ計測

- **Vitest** の組み込みカバレッジ機能 (`@vitest/coverage-v8`) を使用して計測します。
- CIプロセスでカバレッジレポートを生成し、開発者が確認できるようにします（例: Codecov連携）。

### 重点箇所

- ドメインロジック: 90%以上
- APIエンドポイントの主要ロジック: 85%以上
- 認証・認可関連: 90%以上
- 上記以外の箇所も、重要度に応じて適切なカバレッジを確保します。

## モック/スタブ戦略

効果的なテストのためには、依存関係を適切に分離・制御する必要があります。

### モックライブラリ

- **Vitest組み込み機能**:
  - `vi.mock`, `vi.fn`, `vi.spyOn` などのVitestが提供する組み込み関数を第一選択とします。ユニットレベルでの依存モジュールのモック化に最適です。
  - **利点**: 追加のライブラリ導入が不要で、Vitestのテストランナーとシームレスに連携します。
- **Mock Service Worker (MSW)**:
  - **推奨**: フロントエンドとバックエンド間のAPI通信をモック化する場合に強く推奨します。
  - **利点**: ネットワークレベルでリクエストをインターセプトするため、`fetch` や `axios` などの実装詳細に依存せず、実際のAPI通信に近い形でテストを実行できます。APIクライアントコード自体のテストにも有効です。
  - **適用**: 統合テストや、API通信を伴うReactコンポーネントのテスト。

### 外部サービスのモック

- 外部API（AIサービス、決済サービスなど）やSDKとの連携部分は、明確なインターフェース（抽象クラスやTypeScriptの`interface`）を定義します。
- テスト時には、そのインターフェースを実装したモッククラスまたはオブジェクトをDIコンテナ (`tsyringe`) などを通じて注入します。これにより、テスト対象のロジックから外部サービスの実装を切り離します。

### データベースのモック/テスト戦略

- **ユニットテスト**:
  - リポジトリ層の依存は、[04_implementation_rules.md](/docs/restructuring/04_implementation_rules.md) で定義されたリポジトリインターフェースの **インメモリ実装** や **Vitestモック** を使用して分離します。データベースへの実際のアクセスは行いません。
- **統合テスト**:
  - **テストコンテナ (`Testcontainers`)**:
    - **推奨**: 実際のデータベース環境（PostgreSQL）に近い状態でテストを行うためのベストプラクティスとして、`testcontainers-node` ライブラリの利用を強く推奨します。
    - **利点**: テスト実行ごとに独立したDockerコンテナ内で一時的なデータベースインスタンスを起動・破棄するため、テスト間の干渉を防ぎ、実際の環境との差異を最小限に抑えられます。マイグレーションや複雑なクエリのテストに有効です。
  - **テスト用スキーマ/データベース分離**:
    - テストコンテナを使用しない場合や、より高速なセットアップが必要な場合は、テスト実行ごとに専用のデータベースやスキーマを作成・削除する戦略を取ります。
    - [06_utility_functions.md](/docs/restructuring/06_utility_functions.md) の `setupTestDatabase` のようなヘルパー関数を利用し、`beforeAll`/`afterAll` や `beforeEach`/`afterEach` フックでデータベースの状態を管理します。

## テストデータ管理

一貫性があり、意味のあるテストデータは、信頼性の高いテストの基盤です。

### テストデータ生成

- **Faker.js**:
  - **推奨**: ユーザー名、メールアドレス、住所、テキストなど、リアルで多様なテストデータを動的に生成するために活用します。
  - **利点**: ハードコードされたデータよりも現実的なシナリオに近いテストが可能になります。
- **ファクトリ関数/クラス**:
  - **推奨**: 複雑なエンティティやオブジェクト（例: `User`, `Project`, `Step`）を生成するための専用の関数やクラス（ファクトリパターン）を作成します。
  - **利点**: テストコード内でのオブジェクト生成ロジックの重複を避け、設定の共通化や必須項目のデフォルト値設定などが容易になります。テストコードの可読性と保守性が大幅に向上します。例: `createTestUser({ role: 'admin' })` のように利用。

### フィクスチャ

- **静的データ**: 頻繁に使用する固定的なデータセット（例: 国リスト、基本的なロール定義など）は、JSONファイルやTypeScriptの定数オブジェクトとして `tests/fixtures/` ディレクトリなどに配置し、テストコードからインポートして利用します。

### テスト実行ごとのデータ管理

- **独立性の確保**: 各テストケースは、他のテストケースから独立して実行できるように設計します。テストが他のテストの状態に依存したり、影響を与えたりしないようにします。
- **セットアップとクリーンアップ**:
  - Vitestの `beforeEach`/`afterEach` フックを利用して、各テストケースの実行前に必要なデータのセットアップ（例: モックの設定、DBへのレコード挿入）を行い、実行後にクリーンアップ（例: モックのリセット、DBレコードの削除やトランザクションのロールバック）を行います。
  - テストスイート全体で共通のセットアップ/クリーンアップが必要な場合は `beforeAll`/`afterAll` を使用します。

## パフォーマンステスト

### 負荷テストツール

- **k6**: モダンな負荷テストツールとして採用を検討します。JavaScriptでテストシナリオを記述でき、開発者にとって親和性が高いです。
- その他候補: `Locust`, `JMeter` なども要件に応じて検討します。

### テストシナリオ

- [01_requirements_definition.md](/docs/restructuring/01_requirements_definition.md) のパフォーマンス要件（レスポンスタイム、スループット、同時接続数）に基づき、主要なAPIエンドポイントやユーザーシナリオに対する負荷テストを実施します。

### ベンチマーク

- 定期的に（例: リリース前）パフォーマンステストを実施し、ベースラインとなる性能指標（ベンチマーク）を記録します。性能劣化が検知された場合は原因を調査し、対策を講じます。

## セキュリティテスト

### セキュリティテストツール/手法

- **依存関係スキャン**: `npm audit` や `Snyk` を使用して、利用しているライブラリの既知の脆弱性をCI/CDプロセスで継続的にチェックします。
- **静的解析 (SAST)**: `eslint-plugin-security` などのリンタープラグインや、専用のSASTツールを導入し、コードレベルでの潜在的なセキュリティ問題を早期に発見します。
- **動的解析 (DAST)**: 必要に応じて、ステージング環境などで `OWASP ZAP` などのツールを使用し、実行中のアプリケーションに対する脆弱性スキャンを実施します。
- **手動レビュー**: 認証・認可、入力検証、機密データ処理など、セキュリティ上重要な箇所については、コードレビュー時に特に注意深く確認します。

### 脆弱性スキャン頻度

- 依存関係スキャンと静的解析は、CI/CDパイプラインの一部として、コードのプッシュごとに実行します。
- 動的解析は、リリース前や定期的に（例: 四半期ごと）実施することを検討します。

## CIとの連携

### CI設定

- **GitHub Actions**: 主要なCI/CDプラットフォームとして使用します。ワークフローファイル (`.github/workflows/`) でテストプロセスを定義します。

### 自動テスト実行

- コードがリポジトリにプッシュされた際 (`push` イベント) や、プルリクエストが作成・更新された際 (`pull_request` イベント) に、ユニットテスト (`npm run test:unit`)、統合テスト (`npm run test:unit`)、リンター/フォーマッターチェック (`npm run check`) を自動実行します。
- 特定のブランチ（例: `main`, `staging`）へのマージ時やデプロイ前に、E2Eテスト (`npm run test:e2e`) も自動実行します。

### テスト結果の可視化

- GitHub Actionsの実行結果サマリーでテストの成否を確認できます。
- テストカバレッジレポートは、Codecovなどの外部サービスと連携するか、GitHub Actionsのアーティファクトとして保存し、開発者が容易にアクセスできるようにします。

## テスト文化の醸成

### テストレビュー

- プルリクエストのレビュープロセスにおいて、実装コードだけでなく、テストコードもレビューの対象とします。テストの妥当性、網羅性、可読性を評価します。

### テスト品質向上施策

- 定期的にテストコードのリファクタリングを行います。
- テスト失敗時のデバッグを容易にするためのログ出力や情報収集を工夫します。
- 新しいテスト手法やツールの導入を検討し、継続的にテストプロセスを改善します。

### チーム内テスト教育

- テストの重要性や基本的な書き方について、ドキュメントや勉強会を通じてチームメンバーの理解を深めます。
- 効果的なテスト戦略や設計パターンに関する知識共有を促進します。

## ビジュアルリグレッションテスト

### 目的

アプリケーションの UI の見た目が意図せず変更されていないことを保証します。特に CSS の変更、コンポーネントのリファクタリング、ライブラリのアップデート時に視覚的なデグレードを防ぐのに役立ちます。

### ツール

- **Storybook**: コンポーネントの様々な状態をカタログ化し、テスト対象を提供します。
- **Chromatic** (推奨) または `jest-image-snapshot`, `Percy` などのビジュアルテストツール: Storybook と連携し、コンポーネントのスクリーンショットを撮り、ベースラインと比較して差分を検出します。

### 実施プロセス

1.  **ベースライン作成**: 初回実行時または意図的な変更後に、各コンポーネントの Story のスクリーンショットを「ベースライン」として保存します。
2.  **差分検出**: コード変更後のCI/CDパイプラインで再度スクリーンショットを取得し、ベースラインと比較します。
3.  **レビューと承認**: 差分が検出された場合、それが意図した変更であれば承認してベースラインを更新し、意図しない変更（リグレッション）であれば修正します。

### 適用範囲

- 主要なUIコンポーネント (`presentation/components/common`, `presentation/components/layouts`)
- 複数の状態を持つ複雑なコンポーネント (`presentation/components/feature-specific` 内など)
- デザインシステムとして管理されるコンポーネント群

**注意**: 具体的なテストコードの書き方や例については、`code_examples/09_testing_implementation_examples.md` を参照してください。 